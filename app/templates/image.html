{% extends "layouts/base.html" %}

{% block title %}Image Editor{% endblock %}

{% block content %}
<div class="container-fluid" style="padding: 0.5rem 1rem 1rem 1rem;">
    <!-- Tab Navigation - Sát với dashboard tabs -->
    <ul class="nav nav-tabs" id="imageTab" role="tablist" style="margin-bottom: 0.5rem;">
        <li class="nav-item" role="presentation">
            <button class="nav-link {% if not active_tab or active_tab == 'edit' %}active{% endif %}" 
                    id="edit-tab" 
                    data-bs-toggle="tab" 
                    data-bs-target="#edit-panel" 
                    type="button" 
                    role="tab">
                <i class="bi bi-image me-2"></i>Edit Image
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link {% if active_tab == 'collage' %}active{% endif %}" 
                    id="collage-tab" 
                    data-bs-toggle="tab" 
                    data-bs-target="#collage-panel" 
                    type="button" 
                    role="tab">
                <i class="bi bi-grid-3x3 me-2"></i>Photo Collage
            </button>
        </li>
    </ul>

    <!-- Tab Content -->
    <div class="tab-content" id="imageTabContent">
        <!-- Edit Image Tab -->
        <div class="tab-pane fade {% if not active_tab or active_tab == 'edit' %}show active{% endif %}" 
             id="edit-panel" 
             role="tabpanel">
            <div class="row">
                <!-- Left Panel - Tools -->
                <div class="col-md-3">
                    <div class="card bg-dark text-white">
                        <div class="card-header">
                            <h5 class="mb-0">Tools</h5>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label class="form-label">Upload Image</label>
                                <input type="file" class="form-control" id="imageUpload" accept="image/*">
                            </div>
                            
                            <hr>
                            
                            <div class="mb-3">
                                <label class="form-label">Brightness</label>
                                <input type="range" class="form-range" id="brightness" min="0" max="200" value="100">
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Contrast</label>
                                <input type="range" class="form-range" id="contrast" min="0" max="200" value="100">
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Saturation</label>
                                <input type="range" class="form-range" id="saturation" min="0" max="200" value="100">
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Blur</label>
                                <input type="range" class="form-range" id="blur" min="0" max="10" value="0">
                            </div>
                            
                            <hr>
                            
                            <button class="btn btn-primary w-100 mb-2" onclick="applyFilters()">
                                <i class="bi bi-check-circle me-2"></i>Apply
                            </button>
                            <button class="btn btn-secondary w-100 mb-2" onclick="resetFilters()">
                                <i class="bi bi-arrow-counterclockwise me-2"></i>Reset
                            </button>
                            <button class="btn btn-success w-100" onclick="downloadImage()">
                                <i class="bi bi-download me-2"></i>Download
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Right Panel - Canvas -->
                <div class="col-md-9">
                    <div class="card bg-dark text-white">
                        <div class="card-body text-center" style="min-height: 600px;">
                            <canvas id="imageCanvas" style="max-width: 100%; height: auto;"></canvas>
                            <div id="uploadPrompt" class="text-muted">
                                <i class="bi bi-cloud-upload" style="font-size: 4rem;"></i>
                                <p class="mt-3">Upload an image to start editing</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Photo Collage Tab -->
        <div class="tab-pane fade {% if active_tab == 'collage' %}show active{% endif %}" 
             id="collage-panel" 
             role="tabpanel">
            <!-- Top Controls Bar -->
            <div class="card bg-dark text-white mb-3">
                <div class="card-body p-2">
                    <div class="row g-2 align-items-center">
                        <!-- Upload Section -->
                        <div class="col-auto">
                            <label for="collageUpload" style="cursor: pointer; margin: 0;">
                                <button type="button" class="btn btn-info btn-sm" onclick="document.getElementById('collageUpload').click()">
                                    <i class="bi bi-card-image me-1"></i>Select photo(s)
                                </button>
                            </label>
                            <input type="file" class="d-none" id="collageUpload" accept="image/*" multiple>
                        </div>
                        
                        <div class="col-auto"><div class="vr" style="height: 30px;"></div></div>
                        
                        <!-- Ratio -->
                        <div class="col-auto">
                            <div class="d-flex align-items-center gap-2">
                                <label class="form-label mb-0" style="white-space: nowrap;">Ratio</label>
                                <select class="form-select form-select-sm" id="collageAspect" style="width: 100px;">
                                    <option value="1:1" selected>1:1</option>
                                    <option value="3:4">3:4</option>
                                    <option value="4:5">4:5</option>
                                    <option value="16:9">16:9</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="col-auto"><div class="vr" style="height: 30px;"></div></div>
                        
                        <!-- Gutter -->
                        <div class="col-auto">
                            <div class="d-flex align-items-center gap-2">
                                <label class="form-label mb-0" style="white-space: nowrap;">Gutter</label>
                                <input type="range" class="form-range" id="collageGutter" min="0" max="40" value="8" style="width: 100px;">
                                <small class="text-muted" style="min-width: 35px;"><span id="gutterValue">8</span>px</small>
                            </div>
                        </div>
                        
                        <!-- Radius -->
                        <div class="col-auto">
                            <div class="d-flex align-items-center gap-2">
                                <label class="form-label mb-0" style="white-space: nowrap;">Radius</label>
                                <input type="range" class="form-range" id="collageRadius" min="0" max="40" value="0" style="width: 100px;">
                                <small class="text-muted" style="min-width: 35px;"><span id="radiusValue">0</span>px</small>
                            </div>
                        </div>
                        
                        <!-- Border -->
                        <div class="col-auto">
                            <div class="d-flex align-items-center gap-2">
                                <label class="form-label mb-0" style="white-space: nowrap;">Border</label>
                                <input type="range" class="form-range" id="collageBorder" min="0" max="20" value="0" style="width: 100px;">
                                <small class="text-muted" style="min-width: 35px;"><span id="borderValue">0</span>px</small>
                            </div>
                        </div>
                        
                        <!-- Border Color -->
                        <div class="col-auto">
                            <input type="color" class="form-control form-control-color" id="collageBorderColor" value="#ff3b30" title="Border Color" style="width: 50px; height: 32px;">
                        </div>
                        
                        <!-- Background Color -->
                        <div class="col-auto">
                            <input type="color" class="form-control form-control-color" id="collageBackground" value="#111111" title="Background Color" style="width: 50px; height: 32px;">
                        </div>
                        
                        <div class="col-auto"><div class="vr" style="height: 30px;"></div></div>
                        
                        <!-- Swap Button -->
                        <div class="col-auto">
                            <button class="btn btn-outline-info btn-sm" onclick="swapImages()" title="Swap images (S)">
                                <i class="bi bi-arrow-left-right me-1"></i>Swap
                            </button>
                        </div>
                        
                        <div class="col-auto"><div class="vr" style="height: 30px;"></div></div>
                        
                        <!-- Save & Clear Buttons -->
                        <div class="col-auto ms-auto">
                            <button class="btn btn-info btn-sm me-2" onclick="saveCollage()">
                                <i class="bi bi-save me-1"></i>Save
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="clearCollage()">
                                <i class="bi bi-x-circle me-1"></i>Clear
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Preview Area - Full Width -->
            <div class="card bg-dark text-white mb-3">
                <div class="card-body text-center" style="min-height: 650px; max-height: 910px; display: flex; align-items: center; justify-content: center; overflow: auto; padding: 2rem;">
                    <div id="uploadedPhotosPreview" class="row g-2" style="display: none; width: 100%;"></div>
                    <div id="collageCanvasContainer" style="max-width: 50%; max-height: 50%; display: none; margin: 0 auto;">
                        <canvas id="collageCanvas" style="width: 100%; height: auto; display: block; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);"></canvas>
                    </div>
                    <!-- COLLAGE START -->
                    <div id="collage-tiles" style="display: none; height: 720px;">
                        <div id="image-container1" class="tile">
                            <img id="imgL" src="" alt="">
                        </div>
                        <div id="image-container2" class="tile">
                            <img id="imgR" src="" alt="">
                        </div>
                    </div>
                    <!-- COLLAGE END -->
                    <div id="collagePrompt">
                        <i class="bi bi-images" style="font-size: 4rem; color: #6c757d;"></i>
                        <p class="mt-3 text-muted">Upload photos to create a collage</p>
                    </div>
                </div>
            </div>
            
            <!-- Layout Templates - Full Width -->
            <div class="card bg-dark text-white">
                <div class="card-body">
                    <div id="layoutTemplates" class="d-flex gap-2 overflow-auto pb-2">
                        <!-- Layout templates will be generated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    .nav-tabs .nav-link {
        color: #adb5bd;
        background-color: transparent;
        border: 1px solid transparent;
    }
    
    .nav-tabs .nav-link:hover {
        color: #fff;
        border-color: #495057;
    }
    
    .nav-tabs .nav-link.active {
        color: #fff;
        background-color: #495057;
        border-color: #495057;
    }
    
    .card {
        border: 1px solid #495057;
    }
    
    #uploadPrompt {
        padding: 100px 0;
    }
    
    .form-range::-webkit-slider-thumb {
        background: #0d6efd;
    }
    
    .form-range::-moz-range-thumb {
        background: #0d6efd;
    }
</style>

<script>
// ===== EDIT IMAGE TAB =====
let canvas = document.getElementById('imageCanvas');
let ctx = canvas.getContext('2d');
let originalImage = null;
let currentImage = null;

document.getElementById('imageUpload').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                originalImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                currentImage = originalImage;
                document.getElementById('uploadPrompt').style.display = 'none';
                canvas.style.display = 'block';
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }
});

function applyFilters() {
    if (!originalImage) return;
    
    const brightness = document.getElementById('brightness').value;
    const contrast = document.getElementById('contrast').value;
    const saturation = document.getElementById('saturation').value;
    const blur = document.getElementById('blur').value;
    
    ctx.putImageData(originalImage, 0, 0);
    
    // Apply CSS filters
    canvas.style.filter = `
        brightness(${brightness}%)
        contrast(${contrast}%)
        saturate(${saturation}%)
        blur(${blur}px)
    `;
}

function resetFilters() {
    document.getElementById('brightness').value = 100;
    document.getElementById('contrast').value = 100;
    document.getElementById('saturation').value = 100;
    document.getElementById('blur').value = 0;
    canvas.style.filter = '';
    if (originalImage) {
        ctx.putImageData(originalImage, 0, 0);
    }
}

function downloadImage() {
    if (!currentImage) {
        showToast('No image to download', 'warning');
        return;
    }
    
    const link = document.createElement('a');
    link.download = 'edited-image.png';
    link.href = canvas.toDataURL();
    link.click();
    showToast('Image downloaded successfully', 'success');
}

// ===== PHOTO COLLAGE TAB =====
// ===== LOCKED DRAG WITH OBJECT-POSITION =====
function bindLockedDrag(img) {
    if (!img) return;
    img.setAttribute('draggable', 'false');  // chặn drag mặc định của trình duyệt
    img.style.cursor = 'grab';

    let dragging = false;

    img.addEventListener('pointerdown', (e) => {
        dragging = true;
        if (img.setPointerCapture) {
            img.setPointerCapture(e.pointerId);
        }
        img.style.cursor = 'grabbing';
        e.preventDefault();
    }, { passive: false });

    img.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const r = img.getBoundingClientRect();
        let px = ((e.clientX - r.left) / r.width) * 100;
        let py = ((e.clientY - r.top) / r.height) * 100;
        // Clamp 0–100% để không bao giờ hở nền
        px = Math.max(0, Math.min(100, px));
        py = Math.max(0, Math.min(100, py));
        img.style.objectPosition = `${px}% ${py}%`;
        e.preventDefault();
    }, { passive: false });

    const end = () => { 
        dragging = false; 
        img.style.cursor = 'grab'; 
    };
    img.addEventListener('pointerup', end);
    img.addEventListener('pointercancel', end);
}

// ===== HELPER FUNCTIONS FOR CANVAS COLLAGE =====
// Preload ảnh: trả về HTMLImageElement đã sẵn sàng
async function loadImage(src) {
    return new Promise((res, rej) => {
        const im = new Image();
        im.crossOrigin = "anonymous";
        im.onload = () => res(im);
        im.onerror = rej;
        im.src = src;
    });
}

// Tính danh sách cell theo layout cho 3 ảnh
// Trả về mảng các rect: [{x,y,w,h}, ...] (tọa độ pixel trong canvas)
function getCellsForLayout(layoutKey, W, H, gutter) {
    const g = gutter;
    // Mặc định: 1 ảnh bên phải full height, 2 ảnh bên trái chia đôi
    // Đặt tên ví dụ: 'L2_R1' (2 trái 1 phải), 'R2_L1', 'T2_B1' (2 trên 1 dưới), ...
    switch (layoutKey) {
        case 'L2_R1':
        case 'layout-3-left': {
            const colW = Math.floor((W - g) / 2);
            const rightW = W - g - colW;
            const halfH = Math.floor((H - g) / 2);
            return [
                { x: 0,        y: 0,      w: colW, h: halfH },        // left-top
                { x: 0,        y: halfH+g,w: colW, h: H - halfH - g },// left-bottom
                { x: colW+g,   y: 0,      w: rightW, h: H }           // right full
            ];
        }
        case 'R2_L1':
        case 'layout-3-right': {
            const colW = Math.floor((W - g) / 2);
            const leftW = W - g - colW;
            const halfH = Math.floor((H - g) / 2);
            return [
                { x: 0,        y: 0,      w: leftW, h: H },           // left full
                { x: leftW+g,  y: 0,      w: colW, h: halfH },        // right-top
                { x: leftW+g,  y: halfH+g,w: colW, h: H - halfH - g } // right-bottom
            ];
        }
        case 'T2_B1':
        case 'layout-3-top': {
            const rowH = Math.floor((H - g) / 2);
            const topH = rowH, botH = H - g - rowH;
            const halfW = Math.floor((W - g) / 2);
            return [
                { x: 0,      y: 0,     w: halfW,   h: topH },         // top-left
                { x: halfW+g,y: 0,     w: W - halfW - g, h: topH },   // top-right
                { x: 0,      y: topH+g,w: W,       h: botH }          // bottom full
            ];
        }
        case 'B2_T1':
        case 'layout-3-bottom': {
            const rowH = Math.floor((H - g) / 2);
            const topH = H - g - rowH, botH = rowH;
            const halfW = Math.floor((W - g) / 2);
            return [
                { x: 0,      y: 0,     w: W,       h: topH },         // top full
                { x: 0,      y: topH+g,w: halfW,   h: botH },         // bottom-left
                { x: halfW+g,y: topH+g,w: W - halfW - g, h: botH }    // bottom-right
            ];
        }
        case 'layout-3h':
        case 'layout-3-horizontal':
        default: { // 3 cột (fallback)
            const colW = Math.floor((W - 2*g)/3);
            return [
                { x: 0,         y: 0, w: colW,     h: H },
                { x: colW+g,    y: 0, w: colW,     h: H },
                { x: 2*(colW+g),y: 0, w: W - 2*(colW+g) - colW, h: H }
            ];
        }
    }
}

// Clamp offset để không bao giờ hở nền (cover logic)
function clampOffsetForCover(imgW, imgH, cellW, cellH, off) {
    const imgAspect = imgW / imgH;
    const cellAspect = cellW / cellH;

    // Kích thước vẽ theo cover
    let drawW, drawH;
    if (imgAspect > cellAspect) {
        drawH = cellH;
        drawW = Math.ceil(cellH * imgAspect);
    } else {
        drawW = cellW;
        drawH = Math.ceil(cellW / imgAspect);
    }
    // Phần "dư" để có thể pan mà vẫn cover
    const overflowX = Math.max(0, drawW - cellW);
    const overflowY = Math.max(0, drawH - cellH);

    return {
        x: Math.min( overflowX/2, Math.max(-overflowX/2, off.x || 0) ),
        y: Math.min( overflowY/2, Math.max(-overflowY/2, off.y || 0) ),
        drawW, drawH
    };
}

// ===== PHOTO COLLAGE TAB VARIABLES =====
let collageCanvas = document.getElementById('collageCanvas');
let collageCtx = collageCanvas.getContext('2d');
let collageImages = [];
let selectedLayout = null;

// Image position offsets for manual adjustment
let imageOffsets = []; // Array of {x: 0, y: 0} for each image

// Current images and layout for canvas redraw
let currentImages = [];
let currentLayoutKey = null;

// Drag state
let isDragging = false;
let dragImageIndex = -1;
let dragStartX = 0;
let dragStartY = 0;
let dragInitialOffsetX = 0;
let dragInitialOffsetY = 0;

// Layout templates definitions - [col, row, colSpan, rowSpan]
const layoutTemplates = [
    { id: 'layout-1', name: '1 photo', cols: 1, rows: 1, maxPhotos: 1, cells: [[0,0,1,1]] },
    { id: 'layout-2h', name: '2 horizontal', cols: 2, rows: 1, maxPhotos: 2, cells: [[0,0,1,1], [1,0,1,1]] },
    { id: 'layout-2v', name: '2 vertical', cols: 1, rows: 2, maxPhotos: 2, cells: [[0,0,1,1], [0,1,1,1]] },
    { id: 'layout-3h', name: '3 horizontal', cols: 3, rows: 1, maxPhotos: 3, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1]] },
    { id: 'layout-3v', name: '3 vertical', cols: 1, rows: 3, maxPhotos: 3, cells: [[0,0,1,1], [0,1,1,1], [0,2,1,1]] },
    { id: 'layout-3-left', name: '3 left large', cols: 2, rows: 2, maxPhotos: 3, cells: [[0,0,1,2], [1,0,1,1], [1,1,1,1]] },
    { id: 'layout-3-right', name: '3 right large', cols: 2, rows: 2, maxPhotos: 3, cells: [[0,0,1,1], [0,1,1,1], [1,0,1,2]] },
    { id: 'layout-3-top', name: '3 top large', cols: 2, rows: 2, maxPhotos: 3, cells: [[0,0,2,1], [0,1,1,1], [1,1,1,1]] },
    { id: 'layout-3-bottom', name: '3 bottom large', cols: 2, rows: 2, maxPhotos: 3, cells: [[0,0,1,1], [1,0,1,1], [0,1,2,1]] },
    { id: 'layout-2x2', name: '4 grid', cols: 2, rows: 2, maxPhotos: 4, cells: [[0,0,1,1], [1,0,1,1], [0,1,1,1], [1,1,1,1]] },
    { id: 'layout-3x3', name: '9 grid', cols: 3, rows: 3, maxPhotos: 9, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1], [0,1,1,1], [1,1,1,1], [2,1,1,1], [0,2,1,1], [1,2,1,1], [2,2,1,1]] }
];

// Update slider values display and trigger collage update
document.getElementById('collageGutter').addEventListener('input', function(e) {
    document.getElementById('gutterValue').textContent = e.target.value;
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

document.getElementById('collageRadius').addEventListener('input', function(e) {
    document.getElementById('radiusValue').textContent = e.target.value;
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

document.getElementById('collageBorder').addEventListener('input', function(e) {
    document.getElementById('borderValue').textContent = e.target.value;
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

// Auto-update collage when settings change
document.getElementById('collageAspect').addEventListener('change', function() {
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

document.getElementById('collageBorderColor').addEventListener('change', function() {
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

document.getElementById('collageBackground').addEventListener('change', function() {
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

// Render layout templates
function renderLayoutTemplates() {
    const container = document.getElementById('layoutTemplates');
    let html = '';
    
    layoutTemplates.forEach(layout => {
        const isDisabled = collageImages.length > 0 && collageImages.length < layout.maxPhotos;
        const tooltipText = isDisabled 
            ? `Need ${layout.maxPhotos} photos (you have ${collageImages.length})`
            : `${layout.maxPhotos} photo${layout.maxPhotos > 1 ? 's' : ''}`;
        
        // Fixed size for consistent display
        const svgSize = 80;
        const maxDim = Math.max(layout.cols, layout.rows);
        const scale = svgSize / maxDim;
        const svgWidth = layout.cols * scale;
        const svgHeight = layout.rows * scale;
        
        html += `
            <div class="layout-template ${selectedLayout === layout.id ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}" 
                 onclick="${!isDisabled ? `selectLayout('${layout.id}')` : ''}"
                 title="${tooltipText}">
                <svg viewBox="0 0 ${layout.cols * 100} ${layout.rows * 100}" 
                     width="${svgWidth}" 
                     height="${svgHeight}"
                     style="display: block; margin: 0 auto;">
                    ${layout.cells.map(cell => {
                        const [x, y, w, h] = cell;
                        const cellX = x * 100;
                        const cellY = y * 100;
                        const cellW = w * 100;
                        const cellH = h * 100;
                        return `<rect x="${cellX + 3}" y="${cellY + 3}" width="${cellW - 6}" height="${cellH - 6}" 
                                     fill="${isDisabled ? '#2c2c2c' : '#495057'}" 
                                     stroke="${isDisabled ? '#3c3c3c' : '#6c757d'}" 
                                     stroke-width="3"
                                     rx="5" ry="5"/>`;
                    }).join('')}
                </svg>
                <small class="d-block text-center mt-1" style="font-size: 0.65rem; color: #adb5bd;">${layout.maxPhotos}</small>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

function selectLayout(layoutId) {
    const layout = layoutTemplates.find(l => l.id === layoutId);
    if (!layout) return;
    
    // Check if user has enough photos
    if (collageImages.length < layout.maxPhotos) {
        showToast(`This layout requires ${layout.maxPhotos} photos (you have ${collageImages.length})`, 'warning');
        return;
    }
    
    selectedLayout = layoutId;
    renderLayoutTemplates();
    
    if (collageImages.length > 0) {
        createCollageWithLayout();
    }
}

document.getElementById('collageUpload').addEventListener('change', function(e) {
    const files = Array.from(e.target.files);
    if (files.length === 0) return;
    
    collageImages = [];
    imageOffsets = [];
    const previewContainer = document.getElementById('uploadedPhotosPreview');
    previewContainer.innerHTML = '';
    
    let loadedCount = 0;
    files.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                collageImages.push(img);
                loadedCount++;
                
                // Add thumbnail to preview
                const col = document.createElement('div');
                col.className = 'col-auto';
                col.innerHTML = `
                    <div class="position-relative" style="width: 80px; height: 80px;">
                        <img src="${event.target.result}" 
                             class="img-thumbnail" 
                             style="width: 100%; height: 100%; object-fit: cover;">
                    </div>
                `;
                previewContainer.appendChild(col);
                
                if (loadedCount === files.length) {
                    document.getElementById('collagePrompt').style.display = 'none';
                    previewContainer.style.display = 'flex';
                    showToast(`${files.length} photo${files.length > 1 ? 's' : ''} uploaded`, 'success');
                    
                    // Re-render templates to update disabled states
                    renderLayoutTemplates();
                    
                    // Auto-select appropriate layout if none selected or current is invalid
                    if (!selectedLayout || collageImages.length < layoutTemplates.find(l => l.id === selectedLayout)?.maxPhotos) {
                        // For 2 photos, always use horizontal layout
                        if (files.length === 2) {
                            selectLayout('layout-2h');
                        } else {
                            // Find exact match or smallest layout that fits
                            const exactMatch = layoutTemplates.find(l => l.maxPhotos === files.length);
                            const smallestFit = layoutTemplates.filter(l => l.maxPhotos >= files.length).sort((a, b) => a.maxPhotos - b.maxPhotos)[0];
                            
                            if (exactMatch) {
                                selectLayout(exactMatch.id);
                            } else if (smallestFit) {
                                selectLayout(smallestFit.id);
                            }
                        }
                    } else {
                        createCollageWithLayout();
                    }
                }
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });
});

// Create HTML-based collage for 2 horizontal images
function createHTMLCollage() {
    const gutter = parseInt(document.getElementById('collageGutter').value);
    const radius = parseInt(document.getElementById('collageRadius').value);
    const borderWidth = parseInt(document.getElementById('collageBorder').value);
    const borderColor = document.getElementById('collageBorderColor').value;
    const backgroundColor = document.getElementById('collageBackground').value;
    
    const collageTiles = document.getElementById('collage-tiles');
    const imgL = document.getElementById('imgL');
    const imgR = document.getElementById('imgR');
    const container1 = document.getElementById('image-container1');
    const container2 = document.getElementById('image-container2');
    
    // Set images
    if (collageImages.length >= 2) {
        imgL.src = collageImages[0].src;
        imgR.src = collageImages[1].src;
    }
    
    // --- lấy aspect từ selector ---
    const aspect = document.getElementById('collageAspect').value; // '1:1','3:4','4:5','16:9'
    const [arW, arH] = aspect.split(':').map(Number);

    // --- tính chiều cao theo chiều rộng thực tế của #collage-tiles ---
    const tiles = document.getElementById('collage-tiles');
    const maxW = tiles.parentElement.clientWidth;  // vùng preview card
    // trừ padding 2 bên theo gutter để không tràn
    const innerW = Math.max(320, maxW - gutter*2);
    const innerH = Math.round(innerW * arH / arW);

    // set biến CSS để CSS lấy đúng
    tiles.style.setProperty('--canvas-h', `${innerH}px`);
    tiles.style.aspectRatio = `${arW} / ${arH}`; // giúp browser tự co giãn theo tỷ lệ
    
    // Set CSS variables for responsive styling
    collageTiles.style.setProperty('--gutter', `${gutter}px`);
    collageTiles.style.setProperty('--radius', `${radius}px`);
    collageTiles.style.setProperty('--stroke', `${borderWidth}px`);
    collageTiles.style.setProperty('--stroke-color', borderColor);
    
    // Apply background
    collageTiles.style.backgroundColor = backgroundColor;
    collageTiles.style.padding = `${gutter}px`;
    
    // Hide canvas, show tiles
    document.getElementById('collageCanvasContainer').style.display = 'none';
    document.getElementById('uploadedPhotosPreview').style.display = 'none';
    document.getElementById('collagePrompt').style.display = 'none';
    collageTiles.style.display = 'flex';
    
    // Bind drag handlers to all images (if not already bound)
    document.querySelectorAll('#collage-tiles .tile > img').forEach(img => {
        // Remove old listeners if any (by cloning)
        const newImg = img.cloneNode(true);
        img.parentNode.replaceChild(newImg, img);
        bindLockedDrag(newImg);
    });
}

// Apply UI settings
function applyUI() {
    if (selectedLayout === 'layout-2h' && collageImages.length === 2) {
        createHTMLCollage();
    }
}

function createCollageWithLayout() {
    if (collageImages.length === 0 || !selectedLayout) {
        showToast('Please upload photos and select a layout', 'warning');
        return;
    }
    
    const layout = layoutTemplates.find(l => l.id === selectedLayout);
    if (!layout) return;
    
    // Special handling for 2 images layout - use HTML/CSS tiles
    if (collageImages.length === 2) {
        const tiles = document.getElementById('collage-tiles');
        
        if (selectedLayout === 'layout-2h') { 
            // Horizontal layout (default)
            tiles.style.flexDirection = 'row';
            createHTMLCollage(); 
            return; 
        }
        
        if (selectedLayout === 'layout-2v') { 
            // Vertical layout - chuyển tiles sang dạng cột
            tiles.style.flexDirection = 'column';
            createHTMLCollage(); 
            return; 
        }
    }
    
    // Reset flex direction khi không phải 2 ảnh
    const tiles = document.getElementById('collage-tiles');
    tiles.style.flexDirection = 'row';
    
    // ===== CANVAS COLLAGE FOR 3+ IMAGES =====
    createCanvasCollage(collageImages.map(img => img.src), selectedLayout);
}

// New async canvas collage function
async function createCanvasCollage(images, layoutKey) {
    // Save for drag redraw
    currentImages = images;
    currentLayoutKey = layoutKey;
    
    // 1) Kích thước canvas theo tỷ lệ chọn
    const aspect = document.getElementById('collageAspect').value; // '1:1','3:4','4:5','16:9'
    const [arW, arH] = aspect.split(':').map(Number);
    const base = 1080; // cạnh dài để xuất nét
    const CW = arW >= arH ? base : Math.round(base * (arW/arH));
    const CH = arH >= arW ? base : Math.round(base * (arH/arW));

    collageCanvas.width  = CW;
    collageCanvas.height = CH;

    const gutter = parseInt(document.getElementById('collageGutter').value || 0, 10);
    const radius = parseInt(document.getElementById('collageRadius').value || 0, 10);
    const border = parseInt(document.getElementById('collageBorder').value || 0, 10);
    const borderColor = document.getElementById('collageBorderColor').value || '#ff3b30';
    const backgroundColor = document.getElementById('collageBackground').value || '#111111';

    // 2) Preload ảnh (fix lỗi "chỉ 1 ảnh")
    const imgs = await Promise.all(images.map(src => loadImage(src)));

    // 3) Tính cell theo layout
    const cells = getCellsForLayout(layoutKey, CW, CH, gutter);
    // nếu số cell ít hơn số ảnh, chỉ lấy ảnh đầu; nếu nhiều hơn thì lặp lại ảnh cuối
    const n = Math.min(cells.length, imgs.length);

    collageCtx.clearRect(0,0,CW,CH);
    
    // Fill background
    collageCtx.fillStyle = backgroundColor;
    collageCtx.fillRect(0, 0, CW, CH);

    for (let i = 0; i < n; i++) {
        const {x,y,w,h} = cells[i];
        const im = imgs[i];

        // 3a) chuẩn bị cover + clamp offset
        const offRaw = imageOffsets[i] || {x:0,y:0};
        const {x:offX, y:offY, drawW, drawH} = clampOffsetForCover(im.width, im.height, w, h, offRaw);

        // 3b) toạ độ vẽ sao cho ảnh vẫn cover cell
        const drawX = x + Math.round((w - drawW)/2 + offX);
        const drawY = y + Math.round((h - drawH)/2 + offY);

        // 3c) clip tròn góc + vẽ
        collageCtx.save();
        if (radius > 0) {
            const r = Math.min(radius, Math.min(w,h)/2 - 1);
            const p = new Path2D();
            p.moveTo(x+r,y);
            p.arcTo(x+w,y,x+w,y+h,r);
            p.arcTo(x+w,y+h,x,y+h,r);
            p.arcTo(x,y+h,x,y,r);
            p.arcTo(x,y,x+w,y,r);
            p.closePath();
            collageCtx.clip(p);
        } else {
            collageCtx.beginPath();
            collageCtx.rect(x,y,w,h);
            collageCtx.clip();
        }

        collageCtx.drawImage(im, drawX, drawY, drawW, drawH);
        collageCtx.restore();

        // 3d) Border cell (vẽ đúng nét, không *2)
        if (border > 0) {
            collageCtx.save();
            collageCtx.lineWidth = border;
            collageCtx.strokeStyle = borderColor;
            const inset = border/2;
            collageCtx.beginPath();
            if (radius > 0) {
                const r = Math.max(0, Math.min(radius - inset, Math.min(w,h)/2 - inset));
                const p2 = new Path2D();
                p2.moveTo(x+inset+r, y+inset);
                p2.arcTo(x+w-inset, y+inset,   x+w-inset, y+h-inset, r);
                p2.arcTo(x+w-inset, y+h-inset, x+inset,   y+h-inset, r);
                p2.arcTo(x+inset,   y+h-inset, x+inset,   y+inset,   r);
                p2.arcTo(x+inset,   y+inset,   x+w-inset, y+inset,   r);
                p2.closePath();
                collageCtx.stroke(p2);
            } else {
                collageCtx.strokeRect(x+inset, y+inset, w-border, h-border);
            }
            collageCtx.restore();
        }
    }

    // 4) Gắn vùng drag cho từng cell (pan trong giới hạn)
    enableCanvasDrag(cells);
    
    // Show canvas container
    document.getElementById('uploadedPhotosPreview').style.display = 'none';
    document.getElementById('collageCanvasContainer').style.display = 'block';
    document.getElementById('collage-tiles').style.display = 'none';
}

// Kéo trong Canvas – không bao giờ lòi nền
function enableCanvasDrag(cells) {
    let active = -1;
    let start = {x:0, y:0};
    
    collageCanvas.onpointerdown = (e) => {
        const rect = collageCanvas.getBoundingClientRect();
        const cx = (e.clientX - rect.left) * (collageCanvas.width / rect.width);
        const cy = (e.clientY - rect.top)  * (collageCanvas.height / rect.height);
        // chọn cell đang click
        active = cells.findIndex(({x,y,w,h}) => cx>=x && cx<=x+w && cy>=y && cy<=y+h);
        start = {x:cx, y:cy};
        if (collageCanvas.setPointerCapture) {
            collageCanvas.setPointerCapture(e.pointerId);
        }
    };
    
    collageCanvas.onpointermove = (e) => {
        if (active < 0) return;
        const rect = collageCanvas.getBoundingClientRect();
        const cx = (e.clientX - rect.left) * (collageCanvas.width / rect.width);
        const cy = (e.clientY - rect.top)  * (collageCanvas.height / rect.height);
        const dx = cx - start.x, dy = cy - start.y;
        start = {x:cx, y:cy};
        imageOffsets[active] = imageOffsets[active] || {x:0, y:0};
        imageOffsets[active].x += dx;
        imageOffsets[active].y += dy;

        // vẽ lại (clamp sẽ áp trong createCanvasCollage)
        if (currentImages && currentLayoutKey) {
            createCanvasCollage(currentImages, currentLayoutKey);
        }
    };
    
    const end = () => { active = -1; };
    collageCanvas.onpointerup = end;
    collageCanvas.onpointercancel = end;
}

function swapImages() {
    if (collageImages.length < 2) {
        showToast('Need at least 2 images to swap', 'warning');
        return;
    }
    
    // Swap first two images and their offsets
    [collageImages[0], collageImages[1]] = [collageImages[1], collageImages[0]];
    [imageOffsets[0], imageOffsets[1]] = [imageOffsets[1], imageOffsets[0]];
    
    // Redraw collage
    if (selectedLayout) {
        createCollageWithLayout();
        showToast('Images swapped!', 'success');
    }
}

function clearCollage() {
    collageImages = [];
    imageOffsets = [];
    selectedLayout = null;
    document.getElementById('collageCanvasContainer').style.display = 'none';
    document.getElementById('collage-tiles').style.display = 'none';
    document.getElementById('collagePrompt').style.display = 'block';
    document.getElementById('uploadedPhotosPreview').style.display = 'none';
    document.getElementById('uploadedPhotosPreview').innerHTML = '';
    document.getElementById('collageUpload').value = '';
    renderLayoutTemplates();
    showToast('Collage cleared', 'info');
}

function saveCollage() {
    const canvasContainer = document.getElementById('collageCanvasContainer');
    const tilesContainer = document.getElementById('collage-tiles');
    
    // Check if HTML collage is displayed
    if (tilesContainer.style.display !== 'none') {
        // Convert HTML collage to canvas for export
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        tempCanvas.width = 720;
        tempCanvas.height = 720;
        
        const gutter = parseInt(document.getElementById('collageGutter').value);
        const radius = parseInt(document.getElementById('collageRadius').value);
        const borderWidth = parseInt(document.getElementById('collageBorder').value);
        const borderColor = document.getElementById('collageBorderColor').value;
        const backgroundColor = document.getElementById('collageBackground').value;
        
        // Enable high-quality rendering
        tempCtx.imageSmoothingEnabled = true;
        tempCtx.imageSmoothingQuality = 'high';
        
        // Fill background
        tempCtx.fillStyle = backgroundColor;
        tempCtx.fillRect(0, 0, 720, 720);
        
        const halfWidth = (720 - gutter * 3) / 2;
        const imgHeight = 720 - gutter * 2;
        
        // Helper function to draw image with object-position
        function drawImageWithPosition(img, x, y, w, h) {
            if (!img.complete || img.naturalHeight === 0) return;
            
            // Get object-position from style (default 50% 50%)
            const objPos = img.style.objectPosition || '50% 50%';
            const [posX, posY] = objPos.split(' ').map(p => parseFloat(p));
            
            // Calculate source and destination
            const imgAspect = img.naturalWidth / img.naturalHeight;
            const targetAspect = w / h;
            
            tempCtx.save();
            
            // Clip with rounded corners if radius > 0
            if (radius > 0) {
                tempCtx.beginPath();
                tempCtx.moveTo(x + radius, y);
                tempCtx.lineTo(x + w - radius, y);
                tempCtx.quadraticCurveTo(x + w, y, x + w, y + radius);
                tempCtx.lineTo(x + w, y + h - radius);
                tempCtx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
                tempCtx.lineTo(x + radius, y + h);
                tempCtx.quadraticCurveTo(x, y + h, x, y + h - radius);
                tempCtx.lineTo(x, y + radius);
                tempCtx.quadraticCurveTo(x, y, x + radius, y);
                tempCtx.closePath();
                tempCtx.clip();
            }
            
            // Draw image with cover fit
            let drawWidth, drawHeight, drawX, drawY;
            if (imgAspect > targetAspect) {
                drawHeight = h;
                drawWidth = img.naturalWidth * (h / img.naturalHeight);
                drawX = x - (drawWidth - w) * (posX / 100);
                drawY = y;
            } else {
                drawWidth = w;
                drawHeight = img.naturalHeight * (w / img.naturalWidth);
                drawX = x;
                drawY = y - (drawHeight - h) * (posY / 100);
            }
            
            tempCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            tempCtx.restore();
            
            // Draw border if enabled
            if (borderWidth > 0) {
                tempCtx.strokeStyle = borderColor;
                tempCtx.lineWidth = borderWidth;
                
                if (radius > 0) {
                    tempCtx.beginPath();
                    tempCtx.moveTo(x + radius, y);
                    tempCtx.lineTo(x + w - radius, y);
                    tempCtx.quadraticCurveTo(x + w, y, x + w, y + radius);
                    tempCtx.lineTo(x + w, y + h - radius);
                    tempCtx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
                    tempCtx.lineTo(x + radius, y + h);
                    tempCtx.quadraticCurveTo(x, y + h, x, y + h - radius);
                    tempCtx.lineTo(x, y + radius);
                    tempCtx.quadraticCurveTo(x, y, x + radius, y);
                    tempCtx.closePath();
                    tempCtx.stroke();
                } else {
                    tempCtx.strokeRect(x, y, w, h);
                }
            }
        }
        
        // Draw left image
        const imgL = document.getElementById('imgL');
        drawImageWithPosition(imgL, gutter, gutter, halfWidth, imgHeight);
        
        // Draw right image
        const imgR = document.getElementById('imgR');
        drawImageWithPosition(imgR, gutter * 2 + halfWidth, gutter, halfWidth, imgHeight);
        
        // Save
        const link = document.createElement('a');
        link.download = 'photo-collage-hq.png';
        link.href = tempCanvas.toDataURL('image/png', 1.0);
        link.click();
        showToast('High quality collage saved successfully', 'success');
        return;
    }
    
    // Original canvas-based save
    if (canvasContainer.style.display === 'none') {
        showToast('Please create a collage first', 'warning');
        return;
    }
    
    // Save with maximum quality (1.0 = 100% quality)
    const link = document.createElement('a');
    link.download = 'photo-collage-hq.png';
    link.href = collageCanvas.toDataURL('image/png', 1.0); // PNG with max quality
    link.click();
    showToast('High quality collage saved successfully', 'success');
}

// Initialize layout templates on page load
document.addEventListener('DOMContentLoaded', function() {
    renderLayoutTemplates();
    
    // Apply UI if collage is already loaded
    if (typeof applyUI === 'function') {
        applyUI();
    }
    
    // Bind locked drag to all images in collage-tiles
    document.querySelectorAll('#collage-tiles .tile > img').forEach(bindLockedDrag);
    
    // Keyboard shortcuts for collage
    document.addEventListener('keydown', function(e) {
        // Only work in collage tab
        const collageTab = document.getElementById('collage-panel');
        if (!collageTab || !collageTab.classList.contains('active')) return;
        
        // [ key - decrease gutter
        if (e.key === '[') {
            const gutterSlider = document.getElementById('collageGutter');
            const currentValue = parseInt(gutterSlider.value);
            if (currentValue > parseInt(gutterSlider.min)) {
                gutterSlider.value = currentValue - 1;
                document.getElementById('gutterValue').textContent = gutterSlider.value;
                if (selectedLayout && collageImages.length > 0) {
                    createCollageWithLayout();
                }
            }
            e.preventDefault();
        }
        
        // ] key - increase gutter
        if (e.key === ']') {
            const gutterSlider = document.getElementById('collageGutter');
            const currentValue = parseInt(gutterSlider.value);
            if (currentValue < parseInt(gutterSlider.max)) {
                gutterSlider.value = currentValue + 1;
                document.getElementById('gutterValue').textContent = gutterSlider.value;
                if (selectedLayout && collageImages.length > 0) {
                    createCollageWithLayout();
                }
            }
            e.preventDefault();
        }
        
        // S key - swap images
        if (e.key === 's' || e.key === 'S') {
            if (collageImages.length >= 2) {
                swapImages();
                e.preventDefault();
            }
        }
    });
});
</script>

<style>
.layout-template {
    cursor: pointer;
    padding: 12px;
    border: 2px solid #495057;
    border-radius: 8px;
    transition: all 0.3s ease;
    background: #2c3034;
    min-width: 100px;
    min-height: 110px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.layout-template:hover:not(.disabled) {
    border-color: #0dcaf0;
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(13, 202, 240, 0.2);
}

.layout-template.selected {
    border-color: #0dcaf0;
    background: #1a4d5a;
    box-shadow: 0 0 15px rgba(13, 202, 240, 0.4);
}

.layout-template.disabled {
    opacity: 0.3;
    cursor: not-allowed;
    background: #1a1a1a;
}

#uploadedPhotosPreview {
    max-height: 450px;
    overflow-y: auto;
    padding: 10px;
}

#layoutTemplates {
    display: flex;
    gap: 10px;
    overflow-x: auto;
    padding-bottom: 10px;
}

#layoutTemplates::-webkit-scrollbar {
    height: 8px;
}

#layoutTemplates::-webkit-scrollbar-track {
    background: #1a1a1a;
    border-radius: 4px;
}

#layoutTemplates::-webkit-scrollbar-thumb {
    background: #495057;
    border-radius: 4px;
}

#layoutTemplates::-webkit-scrollbar-thumb:hover {
    background: #6c757d;
}

/* Vertical divider */
.vr {
    background-color: #495057;
    opacity: 0.5;
    width: 1px;
}
</style>
{% endblock %}
