{% extends "layouts/base.html" %}

{% block title %}Image Editor{% endblock %}

{% block content %}
<div class="container-fluid" style="padding: 0;">
    
    <!-- Photo Collage - Main Interface -->
    <!-- Top Controls Bar -->
            <div class="card bg-dark text-white" style="margin-bottom: 0; border-bottom: none; border-bottom-left-radius: 0; border-bottom-right-radius: 0; border-top: none; border-top-left-radius: 0; border-top-right-radius: 0;">
                <div class="card-body p-2">
                    <div class="row g-2 align-items-center">
                        <!-- Upload Section -->
                        <div class="col-auto">
                            <label for="collageUpload" style="cursor: pointer; margin: 0;">
                                <button type="button" class="btn btn-info btn-sm" onclick="document.getElementById('collageUpload').click()">
                                    <i class="bi bi-card-image me-1"></i>Select photo(s)
                                </button>
                            </label>
                            <input type="file" class="d-none" id="collageUpload" accept="image/*" multiple>
                        </div>
                        
                        <div class="col-auto"><div class="vr" style="height: 30px;"></div></div>
                        
                        <!-- Ratio -->
                        <div class="col-auto">
                            <div class="d-flex align-items-center gap-2">
                                <label class="form-label mb-0" style="white-space: nowrap;">Ratio</label>
                                <select class="form-select form-select-sm" id="collageAspect" style="width: 100px;">
                                    <option value="1:1" selected>1:1</option>
                                    <option value="3:4">3:4</option>
                                    <option value="4:5">4:5</option>
                                    <option value="16:9">16:9</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="col-auto"><div class="vr" style="height: 30px;"></div></div>
                        
                        <!-- Collage Settings Button with Dropdown -->
                        <div class="col-auto position-relative">
                            <button class="btn btn-outline-secondary btn-sm" id="collageSettingsBtn" 
                                    style="padding: 6px 12px;">
                                <i class="bi bi-grid-3x3-gap" style="font-size: 1.1rem;"></i>
                            </button>
                            
                            <!-- Dropdown Menu -->
                            <div id="collageSettingsMenu" style="display: none; position: absolute; top: 100%; left: 0; margin-top: 4px; background: #1a1a1a; border: 2px solid #495057; border-radius: 8px; padding: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.8); z-index: 2000; min-width: 320px;">
                                <!-- Gutter -->
                                <div style="margin-bottom: 12px;">
                                    <div class="d-flex align-items-center justify-content-between mb-1">
                                        <label class="form-label mb-0" style="color: #adb5bd; font-size: 0.85rem;">Gutter</label>
                                        <small class="text-muted"><span id="gutterValue2">8</span>px</small>
                                    </div>
                                    <input type="range" class="form-range" id="collageGutter" min="0" max="40" value="8" style="width: 100%;">
                                </div>
                                
                                <!-- Radius -->
                                <div style="margin-bottom: 12px;">
                                    <div class="d-flex align-items-center justify-content-between mb-1">
                                        <label class="form-label mb-0" style="color: #adb5bd; font-size: 0.85rem;">Radius</label>
                                        <small class="text-muted"><span id="radiusValue2">0</span>px</small>
                                    </div>
                                    <input type="range" class="form-range" id="collageRadius" min="0" max="40" value="0" style="width: 100%;">
                                </div>
                                
                                <!-- Border -->
                                <div style="margin-bottom: 12px;">
                                    <div class="d-flex align-items-center justify-content-between mb-1">
                                        <label class="form-label mb-0" style="color: #adb5bd; font-size: 0.85rem;">Border</label>
                                        <small class="text-muted"><span id="borderValue2">0</span>px</small>
                                    </div>
                                    <input type="range" class="form-range" id="collageBorder" min="0" max="20" value="0" style="width: 100%;">
                                </div>
                                
                                <!-- Colors -->
                                <div style="display: flex; gap: 12px; padding-top: 8px; border-top: 1px solid #495057;">
                                    <div style="flex: 1;">
                                        <label class="form-label mb-1" style="color: #adb5bd; font-size: 0.8rem;">Border Color</label>
                                        <input type="color" class="form-control form-control-color" id="collageBorderColor" value="#ff3b30" style="width: 100%; height: 38px;">
                                    </div>
                                    <div style="flex: 1;">
                                        <label class="form-label mb-1" style="color: #adb5bd; font-size: 0.8rem;">Background</label>
                                        <input type="color" class="form-control form-control-color" id="collageBackground" value="#111111" style="width: 100%; height: 38px;">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-auto"><div class="vr" style="height: 30px;"></div></div>
                        
                        <!-- Text Button -->
                        <div class="col-auto">
                            <button class="btn btn-outline-warning btn-sm" onclick="toggleTextLayer()" title="Add Text: Click to add, Double-click to edit, Right-click for options">
                                <i class="bi bi-fonts me-1"></i>Text
                            </button>
                        </div>
                        
                        <!-- Blemish Removal Button -->
                        <div class="col-auto">
                            <button class="btn btn-outline-success btn-sm" onclick="toggleBlemishTool()" id="blemishToolBtn" title="Remove blemishes, moles, tattoos - Click and drag on areas to heal">
                                <i class="bi bi-bandaid me-1"></i>Heal
                            </button>
                        </div>
                        
                        <!-- Crop Button -->
                        <div class="col-auto">
                            <button class="btn btn-outline-info btn-sm" onclick="toggleCropTool()" id="cropToolBtn" title="Crop image - Adjust frame and press Enter to apply">
                                <i class="bi bi-scissors me-1"></i>Crop
                            </button>
                        </div>
                        
                        <!-- Enhance Button -->
                        <div class="col-auto">
                            <button class="btn btn-outline-primary btn-sm" onclick="enhanceImage()" id="enhanceBtn" title="Enhance image quality - CLAHE, sharpen, denoise">
                                <i class="bi bi-stars me-1"></i>Enhance
                            </button>
                        </div>
                        
                        <div class="col-auto"><div class="vr" style="height: 30px;"></div></div>
                        
                        <!-- Save & Clear Buttons -->
                        <div class="col-auto ms-auto">
                            <button class="btn btn-info btn-sm me-2" onclick="saveCollage()">
                                <i class="bi bi-save me-1"></i>Save
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="clearCollage()">
                                <i class="bi bi-x-circle me-1"></i>Clear
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Preview Area - Full Width -->
            <div class="card bg-dark text-white" style="margin-bottom: 0; border-top: none; border-top-left-radius: 0; border-top-right-radius: 0;">
                <div class="card-body text-center" style="min-height: 650px; height: calc(100vh - 140px); display: flex; align-items: center; justify-content: center; overflow: auto; padding: 2rem; position: relative;">
                    
                    <!-- LEFT SIDEBAR - Collage History (Inside Preview) -->
                    <div id="historyPanel" style="position: absolute; left: 0; top: 0; width: 180px; height: 100%; background: rgba(26, 26, 26, 0.95); border-right: 1px solid #495057; overflow-y: auto; padding: 8px; z-index: 100;">
                        <div style="font-size: 0.75rem; font-weight: 600; color: #adb5bd; margin-bottom: 8px; padding: 4px; display: flex; align-items: center; justify-content: space-between;">
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <i class="bi bi-clock-history"></i>
                                <span>History</span>
                            </div>
                            <button onclick="clearAllHistory()" title="Clear all history" 
                                    style="background: none; border: none; color: #dc3545; cursor: pointer; padding: 2px 6px; font-size: 1rem; transition: all 0.2s;">
                                <i class="bi bi-trash-fill"></i>
                            </button>
                        </div>
                        <div id="collageHistory" class="d-flex flex-column gap-2">
                            <!-- History items will be generated here -->
                            <small class="text-muted text-center py-3" style="font-size: 0.7rem;">No saved collages</small>
                        </div>
                    </div>
                    
                    <div id="uploadedPhotosPreview" class="row g-2" style="display: none; width: 100%;"></div>
                    
                    <!-- Single Image Viewer (for 1 photo) -->
                    <div id="singleImageViewer" style="display: none; width: 100%; height: 100%; position: relative;">
                        <canvas id="singleImageCanvas" style="max-width: 100%; max-height: 100%; object-fit: contain; cursor: grab;"></canvas>
                    </div>
                    
                    <div id="collageCanvasContainer" style="max-width: 50%; max-height: 50%; display: none; margin: 0 auto;">
                        <canvas id="collageCanvas" style="width: 100%; height: auto; display: block; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);"></canvas>
                    </div>
                    
                    <!-- Layout Templates Panel - Inside Preview (Right Side) -->
                    <div id="templatesPanel" style="position: absolute; right: 0; top: 0; width: 200px; height: 100%; background: rgba(26, 26, 26, 0.95); z-index: 100; overflow-y: auto; padding: 10px; display: none;">
                        <div id="layoutTemplates" class="d-flex flex-column gap-2">
                            <!-- Layout templates will be generated here -->
                        </div>
                    </div>
                    
                    <!-- Text Layers Container -->
                    <div id="textLayersContainer" style="position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50;">
                        <!-- Text layers will be added here -->
                    </div>
                    
                    <!-- COLLAGE START -->
                    <div id="collage-tiles" style="display: none; height: 720px;">
                        <!-- Tiles will be generated dynamically for each layout -->
                    </div>
                    <!-- COLLAGE END -->
                    <div id="collagePrompt">
                        <i class="bi bi-images" style="font-size: 4rem; color: #6c757d;"></i>
                        <p class="mt-3 text-muted">Upload photos to create a collage</p>
                    </div>
                </div>
            </div>
            
        </div><!-- Close collage interface -->
    </div><!-- Close container -->

<!-- Text Context Menu (Right-click on text) -->
<div id="textContextMenu" style="display: none; position: fixed; z-index: 2000; background: #1a1a1a; border: 2px solid #495057; border-radius: 8px; padding: 0; box-shadow: 0 8px 32px rgba(0,0,0,0.8); min-width: 200px; overflow: hidden;">
    
    <!-- Color Menu Item -->
    <div class="context-menu-item" id="colorMenuItem" style="position: relative; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #495057; display: flex; align-items: center; justify-content: space-between;">
        <span style="color: #fff; font-size: 0.9rem;">
            <i class="bi bi-palette" style="margin-right: 8px;"></i>Color
        </span>
        <i class="bi bi-chevron-right" style="color: #6c757d; font-size: 0.8rem;"></i>
    </div>
    
    <!-- Font Menu Item -->
    <div class="context-menu-item" id="fontMenuItem" style="position: relative; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #495057; display: flex; align-items: center; justify-content: space-between;">
        <span style="color: #fff; font-size: 0.9rem;">
            <i class="bi bi-fonts" style="margin-right: 8px;"></i>Font
        </span>
        <i class="bi bi-chevron-right" style="color: #6c757d; font-size: 0.8rem;"></i>
    </div>
    
    <!-- Delete Menu Item -->
    <div class="context-menu-item" onclick="deleteCurrentTextLayer()" style="padding: 10px 15px; cursor: pointer; color: #dc3545;">
        <i class="bi bi-trash" style="margin-right: 8px;"></i>Delete
    </div>
</div>

<!-- Color Submenu (Appears on hover) -->
<div id="colorSubmenu" style="display: none; position: fixed; z-index: 2001; background: #1a1a1a; border: 2px solid #495057; border-radius: 8px; padding: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.8); min-width: 280px;">
    <div style="font-size: 0.85rem; color: #adb5bd; margin-bottom: 10px; font-weight: 600;">Color Picker</div>
    
    <!-- Preset Colors Grid -->
    <div id="presetColors" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; margin-bottom: 12px;">
        <!-- Will be populated by JS -->
    </div>
    
    <!-- Color Code Input -->
    <div style="margin-bottom: 10px;">
        <input type="text" id="colorCodeInput" placeholder="#FFFFFF" maxlength="7" 
               style="width: 100%; padding: 8px 12px; background: #0d0d0d; border: 1px solid #495057; border-radius: 4px; color: #fff; font-family: monospace; font-size: 0.9rem;"
               onkeypress="if(event.key==='Enter') applyCustomColor()">
    </div>
    
    <!-- Rainbow Checkbox -->
    <div style="display: flex; align-items: center; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
        <input type="checkbox" id="rainbowCheckbox" style="width: 18px; height: 18px; margin-right: 10px; cursor: pointer;"
               onchange="applyRainbowMode(this.checked)">
        <label for="rainbowCheckbox" style="color: #fff; cursor: pointer; margin: 0; user-select: none; font-size: 0.9rem;">
            üåà Rainbow (7 colors)
        </label>
    </div>
</div>

<!-- Font Submenu (Appears on hover) -->
<div id="fontSubmenu" style="display: none; position: fixed; z-index: 2001; background: #1a1a1a; border: 2px solid #495057; border-radius: 8px; padding: 8px; box-shadow: 0 8px 32px rgba(0,0,0,0.8); min-width: 220px; max-height: 400px; overflow-y: auto;">
    <div style="font-size: 0.85rem; color: #adb5bd; margin-bottom: 8px; padding: 0 8px; font-weight: 600;">Select Font</div>
    <div id="fontList">
        <!-- Will be populated by JS -->
    </div>
</div>

<style>
    .context-menu-item:hover {
        background: rgba(13, 202, 240, 0.2);
    }
    
    .font-item {
        padding: 10px 12px;
        cursor: pointer;
        border-radius: 4px;
        color: #fff;
        font-size: 0.9rem;
        margin-bottom: 2px;
        transition: all 0.2s;
    }
    
    .font-item:hover {
        background: rgba(13, 202, 240, 0.3);
        transform: translateX(4px);
    }
    
    .color-preset {
        width: 28px;
        height: 28px;
        border-radius: 4px;
        cursor: pointer;
        border: 2px solid transparent;
        transition: all 0.2s;
    }
    
    .color-preset:hover {
        border-color: #0dcaf0;
        transform: scale(1.15);
    }
    
    #colorSubmenu::-webkit-scrollbar,
    #fontSubmenu::-webkit-scrollbar {
        width: 6px;
    }
    
    #colorSubmenu::-webkit-scrollbar-track,
    #fontSubmenu::-webkit-scrollbar-track {
        background: #0d0d0d;
    }
    
    #colorSubmenu::-webkit-scrollbar-thumb,
    #fontSubmenu::-webkit-scrollbar-thumb {
        background: #495057;
        border-radius: 3px;
    }
    
    .card {
        border: 1px solid #495057;
    }
    
    /* Collage History Styles */
    #historyPanel {
        scrollbar-width: thin;
        scrollbar-color: #495057 #1a1a1a;
    }
    
    #historyPanel::-webkit-scrollbar,
    #templatesPanel::-webkit-scrollbar {
        width: 6px;
    }
    
    #historyPanel::-webkit-scrollbar-track,
    #templatesPanel::-webkit-scrollbar-track {
        background: #1a1a1a;
    }
    
    #historyPanel::-webkit-scrollbar-thumb,
    #templatesPanel::-webkit-scrollbar-thumb {
        background: #495057;
        border-radius: 3px;
    }
    
    /* Inline Text Editing - ContentEditable Style */
    .text-layer-content[contenteditable="true"] {
        background: rgba(0, 0, 0, 0.7) !important;
        outline: 3px solid #0dcaf0 !important;
        outline-offset: 2px;
        cursor: text !important;
        animation: pulse-outline 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse-outline {
        0%, 100% {
            outline-color: #0dcaf0;
            box-shadow: 0 0 10px rgba(13, 202, 240, 0.4);
        }
        50% {
            outline-color: #0d6efd;
            box-shadow: 0 0 20px rgba(13, 110, 253, 0.6);
        }
    }
    
    .text-layer-content {
        cursor: move;
        user-select: none;
        transition: all 0.2s ease;
        display: inline-block;
    }
    
    .text-layer-content:hover {
        transform: scale(1.02);
        filter: brightness(1.1);
    }
    
    .text-layer-wrapper {
        cursor: move !important;
    }
    
    .text-layer-toolbar {
        position: absolute;
        top: -35px;
        left: 0;
        background: rgba(26, 26, 26, 0.95);
        border: 1px solid #495057;
        border-radius: 4px;
        padding: 4px 8px;
        display: flex;
        gap: 6px;
        z-index: 1000;
    }
    
    .text-layer-toolbar button {
        padding: 2px 8px;
        font-size: 0.8rem;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .text-layer-toolbar button:hover {
        transform: scale(1.05);
    }
    
    .history-item {
        position: relative;
        background: #0d0d0d;
        border: 1px solid #495057;
        border-radius: 6px;
        padding: 3px;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .history-item:hover {
        border-color: #0dcaf0;
        transform: scale(1.02);
        box-shadow: 0 2px 6px rgba(13, 202, 240, 0.4);
    }
    
    .history-item img {
        width: 100%;
        height: auto;
        border-radius: 4px;
        display: block;
    }
    
    .history-item-date {
        font-size: 0.6rem;
        color: #6c757d;
        text-align: center;
        margin-top: 2px;
        font-weight: 500;
    }
    
    /* Context Menu */
    .context-menu {
        position: fixed;
        background: #212529;
        border: 1px solid #495057;
        border-radius: 4px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        z-index: 10000;
        min-width: 120px;
    }
    
    .context-menu-item {
        padding: 8px 16px;
        cursor: pointer;
        color: #fff;
        transition: background 0.2s;
    }
    
    .context-menu-item:hover {
        background: #dc3545;
    }
    
    .context-menu-item i {
        margin-right: 8px;
    }
</style>

{% raw %}
<script>
// ===== NAVBAR NAVIGATION HANDLER =====
function handleImageNavClick(event) {
    // If already on /image page, prevent reload
    if (window.location.pathname.startsWith('/image')) {
        event.preventDefault();
        console.log('Already on image page, prevented reload');
        return false;
    }
    return true; // Allow navigation if on different page
}

// ===== AUTO-SAVE & RESTORE SYSTEM =====
// Use localStorage instead of sessionStorage to persist across browser close
const STORAGE_KEY_EDIT_IMAGE = 'stool_edit_image_cache'; // Legacy, kept for compatibility
const STORAGE_KEY_COLLAGE_IMAGES = 'stool_collage_images_cache';
const STORAGE_KEY_COLLAGE_HISTORY = 'stool_collage_history';

// Save image to localStorage
function saveImageToCache(data, type = 'edit') {
    try {
        const key = type === 'edit' ? STORAGE_KEY_EDIT_IMAGE : STORAGE_KEY_COLLAGE_IMAGES;
        // If data is array (collage images), stringify it
        const valueToStore = Array.isArray(data) ? JSON.stringify(data) : data;
        localStorage.setItem(key, valueToStore);
        console.log(`‚úÖ Image saved to cache (${type})`, Array.isArray(data) ? `${data.length} images` : '');
    } catch (e) {
        console.warn('‚ö†Ô∏è Failed to save image to cache:', e);
    }
}

// Load image from localStorage
function loadImageFromCache(type = 'edit') {
    try {
        const key = type === 'edit' ? STORAGE_KEY_EDIT_IMAGE : STORAGE_KEY_COLLAGE_IMAGES;
        const dataURL = localStorage.getItem(key);
        if (dataURL) {
            console.log(`‚úÖ Image loaded from cache (${type})`);
            return dataURL;
        }
    } catch (e) {
        console.warn('‚ö†Ô∏è Failed to load image from cache:', e);
    }
    return null;
}

// Clear cache
function clearImageCache(type = 'edit') {
    const key = type === 'edit' ? STORAGE_KEY_EDIT_IMAGE : STORAGE_KEY_COLLAGE_IMAGES;
    localStorage.removeItem(key);
    console.log(`üóëÔ∏è Cache cleared (${type})`);
}

// ===== COLLAGE HISTORY MANAGEMENT =====
function saveToHistory(imageDataArray) {
    try {
        const history = JSON.parse(localStorage.getItem(STORAGE_KEY_COLLAGE_HISTORY) || '[]');
        
        const newEntry = {
            id: Date.now().toString(),
            timestamp: new Date().toISOString(),
            date: new Date().toLocaleString('vi-VN'),
            imageCount: imageDataArray.length,
            images: imageDataArray // Array of base64 dataURLs
        };
        
        // Add to beginning of history
        history.unshift(newEntry);
        
        // Keep only last 50 entries
        if (history.length > 50) {
            history.splice(50);
        }
        
        localStorage.setItem(STORAGE_KEY_COLLAGE_HISTORY, JSON.stringify(history));
        console.log(`‚úÖ Saved to history: ${newEntry.imageCount} images`);
        
        // Reload history display
        loadCollageHistoryFromStorage();
        
        return newEntry.id;
    } catch (e) {
        console.error('Failed to save to history:', e);
        return null;
    }
}

function loadCollageHistoryFromStorage() {
    try {
        const history = JSON.parse(localStorage.getItem(STORAGE_KEY_COLLAGE_HISTORY) || '[]');
        const container = document.getElementById('collageHistory');
        
        if (history.length === 0) {
            container.innerHTML = '<small class="text-muted text-center py-3">No saved collages</small>';
            return;
        }
        
        container.innerHTML = history.map(item => {
            // Create thumbnail from first image
            const thumbnailSrc = item.images[0] || '';
            return `
                <div class="history-item" 
                     data-id="${item.id}"
                     title="${item.date} - ${item.imageCount} photos"
                     onclick="loadHistoryForEdit('${item.id}')"
                     oncontextmenu="showHistoryContextMenu(event, '${item.id}'); return false;">
                    <img src="${thumbnailSrc}" alt="Collage">
                    <div class="history-item-date">${item.imageCount} photos</div>
                </div>
            `;
        }).join('');
        
        console.log(`‚úÖ Loaded ${history.length} history items`);
    } catch (e) {
        console.error('Failed to load history:', e);
    }
}

function loadHistoryForEdit(historyId) {
    try {
        const history = JSON.parse(localStorage.getItem(STORAGE_KEY_COLLAGE_HISTORY) || '[]');
        const item = history.find(h => h.id === historyId);
        
        if (!item) {
            showToast('History item not found', 'danger');
            return;
        }
        
        // Clear current state
        collageImages = [];
        imageOffsets = [];
        imagePositions = [];
        textLayers = [];
        document.getElementById('textLayersContainer').innerHTML = '';
        selectedLayout = null;
        
        const previewContainer = document.getElementById('uploadedPhotosPreview');
        previewContainer.innerHTML = '';
        
        let loadedCount = 0;
        
        // Load all images from history
        item.images.forEach((dataURL, index) => {
            const img = new Image();
            img.onload = function() {
                collageImages.push(img);
                loadedCount++;
                
                // Add thumbnail to preview
                const col = document.createElement('div');
                col.className = 'col-auto';
                col.innerHTML = `
                    <div class="position-relative" style="width: 80px; height: 80px;">
                        <img src="${dataURL}" 
                             class="img-thumbnail" 
                             style="width: 100%; height: 100%; object-fit: cover;">
                    </div>
                `;
                previewContainer.appendChild(col);
                
                if (loadedCount === item.images.length) {
                    document.getElementById('collagePrompt').style.display = 'none';
                    
                    // Check if single image
                    if (item.images.length === 1) {
                        showSingleImageViewer(collageImages[0]);
                        showToast(`Loaded 1 photo from history`, 'success');
                    } else {
                        // Hide single image viewer
                        document.getElementById('singleImageViewer').style.display = 'none';
                        
                        previewContainer.style.display = 'flex';
                        
                        // Hide canvas/tiles
                        document.getElementById('collageCanvasContainer').style.display = 'none';
                        const tiles = document.getElementById('collage-tiles');
                        if (tiles) tiles.style.display = 'none';
                        
                        // Save to current cache
                        saveImageToCache(item.images, 'collage');
                        
                        // Re-render templates
                        renderLayoutTemplates();
                        
                        // Auto-select matching layout
                        const matchingLayout = layoutTemplates.find(l => l.maxPhotos === item.images.length);
                        if (matchingLayout) {
                            selectLayout(matchingLayout.id);
                        }
                        
                        showToast(`Loaded ${item.imageCount} photos from history`, 'success');
                    }
                }
            };
            img.src = dataURL;
        });
        
    } catch (e) {
        console.error('Failed to load history for edit:', e);
        showToast('Error loading history', 'danger');
    }
}

function showHistoryContextMenu(event, historyId) {
    event.preventDefault();
    event.stopPropagation();
    
    // Remove existing context menu
    const existing = document.querySelector('.context-menu');
    if (existing) existing.remove();
    
    // Create context menu
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.style.left = event.pageX + 'px';
    menu.style.top = event.pageY + 'px';
    menu.innerHTML = `
        <div class="context-menu-item" onclick="deleteFromHistory('${historyId}'); event.stopPropagation();">
            <i class="bi bi-trash"></i>Delete
        </div>
    `;
    
    document.body.appendChild(menu);
    
    // Close on click outside
    const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
        }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 100);
}

function deleteFromHistory(historyId) {
    try {
        // Remove context menu first
        const existingMenu = document.querySelector('.context-menu');
        if (existingMenu) existingMenu.remove();
        
        let history = JSON.parse(localStorage.getItem(STORAGE_KEY_COLLAGE_HISTORY) || '[]');
        history = history.filter(h => h.id !== historyId);
        localStorage.setItem(STORAGE_KEY_COLLAGE_HISTORY, JSON.stringify(history));
        loadCollageHistoryFromStorage();
        showToast('Deleted from history', 'info');
    } catch (e) {
        console.error('Failed to delete from history:', e);
        showToast('Error deleting from history', 'danger');
    }
}

// ===== PHOTO COLLAGE - MAIN INTERFACE =====
// Global flag to lock/unlock image dragging
let isImageDraggingLocked = false;

// Function to lock/unlock image dragging (used when editing text)
function lockImageDragging(lock) {
    isImageDraggingLocked = lock;
    const collageTiles = document.getElementById('collage-tiles');
    
    if (lock) {
        // Lock: disable pointer events on all images and show overlay
        collageTiles.style.pointerEvents = 'none';
        collageTiles.style.opacity = '0.6';
        collageTiles.style.filter = 'blur(1px)';
        console.log('üîí Image dragging LOCKED (editing text)');
    } else {
        // Unlock: enable pointer events on all images
        collageTiles.style.pointerEvents = 'auto';
        collageTiles.style.opacity = '1';
        collageTiles.style.filter = 'none';
        console.log('üîì Image dragging UNLOCKED');
    }
}

// ===== SINGLE IMAGE VIEWER MODE =====
let singleImageZoom = 1;
let singleImageCanvas = null;
let singleImageCtx = null;
let zoomListener = null; // Track the listener

// ===== UNDO FUNCTIONALITY =====
let canvasHistory = [];
let maxHistorySize = 20;

function saveCanvasState() {
    if (!singleImageCanvas || !singleImageCtx) return;
    
    // Save current canvas state as data URL
    const state = singleImageCanvas.toDataURL();
    canvasHistory.push(state);
    
    // Limit history size
    if (canvasHistory.length > maxHistorySize) {
        canvasHistory.shift();
    }
    
    console.log(`üíæ Canvas state saved (${canvasHistory.length} in history)`);
}

function undoCanvas() {
    if (canvasHistory.length === 0) {
        showToast('No more undo history', 'info');
        return;
    }
    
    // Remove current state
    canvasHistory.pop();
    
    if (canvasHistory.length === 0) {
        showToast('Reached initial state', 'info');
        return;
    }
    
    // Restore previous state
    const previousState = canvasHistory[canvasHistory.length - 1];
    const img = new Image();
    img.onload = function() {
        singleImageCtx.clearRect(0, 0, singleImageCanvas.width, singleImageCanvas.height);
        singleImageCanvas.width = img.width;
        singleImageCanvas.height = img.height;
        singleImageCtx.drawImage(img, 0, 0);
        showToast('‚Ü©Ô∏è Undo successful', 'success');
    };
    img.src = previousState;
}

// Setup Ctrl+Z listener
document.addEventListener('keydown', function(e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        if (collageImages.length === 1) {
            undoCanvas();
        }
    }
});

function showSingleImageViewer(image) {
    // Hide collage elements
    document.getElementById('uploadedPhotosPreview').style.display = 'none';
    document.getElementById('collage-tiles').style.display = 'none';
    document.getElementById('collageCanvasContainer').style.display = 'none';
    document.getElementById('templatesPanel').style.display = 'none';
    
    // Show single viewer
    const viewer = document.getElementById('singleImageViewer');
    viewer.style.display = 'flex';
    viewer.style.alignItems = 'center';
    viewer.style.justifyContent = 'center';
    
    // Setup canvas
    singleImageCanvas = document.getElementById('singleImageCanvas');
    singleImageCtx = singleImageCanvas.getContext('2d');
    
    // RESET zoom and remove old listener
    singleImageZoom = 1;
    singleImageCanvas.style.transform = 'scale(1)';
    if (zoomListener) {
        singleImageCanvas.removeEventListener('wheel', zoomListener);
    }
    
    // Set canvas size to fit container
    const container = viewer.parentElement;
    const maxWidth = container.clientWidth - 40;
    const maxHeight = container.clientHeight - 40;
    
    let scale = Math.min(maxWidth / image.width, maxHeight / image.height);
    singleImageCanvas.width = image.width * scale;
    singleImageCanvas.height = image.height * scale;
    
    // Draw image
    singleImageCtx.clearRect(0, 0, singleImageCanvas.width, singleImageCanvas.height);
    singleImageCtx.drawImage(image, 0, 0, singleImageCanvas.width, singleImageCanvas.height);
    
    // Save initial state for undo
    canvasHistory = []; // Clear history for new image
    saveCanvasState();
    
    // Add zoom functionality with new listener
    zoomListener = handleSingleImageZoom;
    singleImageCanvas.addEventListener('wheel', zoomListener, { passive: false });
}

function handleSingleImageZoom(e) {
    e.preventDefault();
    
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    singleImageZoom *= delta;
    singleImageZoom = Math.max(0.1, Math.min(5, singleImageZoom)); // Clamp 0.1x - 5x
    
    singleImageCanvas.style.transform = `scale(${singleImageZoom})`;
    singleImageCanvas.style.transition = 'transform 0.1s';
}

// ===== DRAG & DROP + PASTE IMAGES =====
function setupDragDropPaste() {
    const dropZone = document.body;
    
    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    // Highlight drop zone
    ['dragenter', 'dragover'].forEach(eventName => {
        dropZone.addEventListener(eventName, () => {
            dropZone.style.outline = '3px dashed #0dcaf0';
        });
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, () => {
            dropZone.style.outline = '';
        });
    });
    
    // Handle dropped files
    dropZone.addEventListener('drop', handleDrop);
    
    // Handle paste
    document.addEventListener('paste', handlePaste);
}

function handleDrop(e) {
    const dt = e.dataTransfer;
    const files = Array.from(dt.files).filter(f => f.type.startsWith('image/'));
    
    if (files.length > 0) {
        processUploadedFiles(files);
    }
}

function handlePaste(e) {
    const items = e.clipboardData.items;
    const imageFiles = [];
    
    for (let item of items) {
        if (item.type.startsWith('image/')) {
            const file = item.getAsFile();
            if (file) imageFiles.push(file);
        }
    }
    
    if (imageFiles.length > 0) {
        processUploadedFiles(imageFiles);
    }
}

function processUploadedFiles(files) {
    collageImages = [];
    imageOffsets = [];
    imagePositions = [];
    const previewContainer = document.getElementById('uploadedPhotosPreview');
    previewContainer.innerHTML = '';
    
    const imageDataURLs = [];
    let loadedCount = 0;
    
    files.forEach((file) => {
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                collageImages.push(img);
                imageDataURLs.push(event.target.result);
                loadedCount++;
                
                // Add thumbnail
                const col = document.createElement('div');
                col.className = 'col-auto';
                col.innerHTML = `
                    <div class="position-relative" style="width: 80px; height: 80px;">
                        <img src="${event.target.result}" 
                             class="img-thumbnail" 
                             style="width: 100%; height: 100%; object-fit: cover;">
                    </div>
                `;
                previewContainer.appendChild(col);
                
                if (loadedCount === files.length) {
                    document.getElementById('collagePrompt').style.display = 'none';
                    
                    if (files.length === 1) {
                        showSingleImageViewer(collageImages[0]);
                        showToast('1 photo added - Single viewer mode', 'success');
                    } else {
                        previewContainer.style.display = 'flex';
                        showToast(`${files.length} photos added`, 'success');
                        renderLayoutTemplates();
                        const matchingLayout = layoutTemplates.find(l => l.maxPhotos === files.length);
                        if (matchingLayout) selectLayout(matchingLayout.id);
                    }
                    
                    saveImageToCache(imageDataURLs, 'collage');
                    saveToHistory(imageDataURLs);
                }
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });
}

// ===== CLEAR ALL HISTORY =====
function clearAllHistory() {
    localStorage.removeItem(STORAGE_KEY_COLLAGE_HISTORY);
    loadCollageHistoryFromStorage();
    showToast('All history cleared', 'info');
}

// ===== BLEMISH REMOVAL TOOL (HEALING BRUSH) =====
let blemishToolActive = false;
let blemishBrushSize = 12; // Reduced from 20 to 12
let isHealing = false;
let healingPoints = [];
let lastHealX = -1;
let lastHealY = -1;

function toggleBlemishTool() {
    if (collageImages.length === 0) {
        showToast('Upload a photo first!', 'warning');
        return;
    }
    
    // Only works in single image mode
    if (collageImages.length > 1) {
        showToast('Blemish tool only works with single images', 'info');
        return;
    }
    
    blemishToolActive = !blemishToolActive;
    const btn = document.getElementById('blemishToolBtn');
    
    if (blemishToolActive) {
        btn.classList.add('active');
        btn.style.backgroundColor = '#198754';
        btn.style.color = 'white';
        singleImageCanvas.style.cursor = 'crosshair';
        setupBlemishListeners();
        showToast('ü©π Click and drag to heal blemishes', 'success');
    } else {
        btn.classList.remove('active');
        btn.style.backgroundColor = '';
        btn.style.color = '';
        singleImageCanvas.style.cursor = 'grab';
        removeBlemishListeners();
        showToast('Healing tool disabled', 'info');
    }
}

function setupBlemishListeners() {
    singleImageCanvas.addEventListener('mousedown', startHealing);
    singleImageCanvas.addEventListener('mousemove', continueHealing);
    singleImageCanvas.addEventListener('mouseup', endHealing);
    singleImageCanvas.addEventListener('mouseleave', endHealing);
}

function removeBlemishListeners() {
    singleImageCanvas.removeEventListener('mousedown', startHealing);
    singleImageCanvas.removeEventListener('mousemove', continueHealing);
    singleImageCanvas.removeEventListener('mouseup', endHealing);
    singleImageCanvas.removeEventListener('mouseleave', endHealing);
}

function startHealing(e) {
    if (!blemishToolActive) return;
    
    // Save canvas state before healing
    saveCanvasState();
    
    isHealing = true;
    healingPoints = [];
    const rect = singleImageCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (singleImageCanvas.width / rect.width);
    const y = (e.clientY - rect.top) * (singleImageCanvas.height / rect.height);
    lastHealX = x;
    lastHealY = y;
    healingPoints.push({x, y});
    healBlemish(x, y);
}

function continueHealing(e) {
    if (!isHealing || !blemishToolActive) return;
    const rect = singleImageCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (singleImageCanvas.width / rect.width);
    const y = (e.clientY - rect.top) * (singleImageCanvas.height / rect.height);
    
    // Only heal if moved at least 3 pixels (prevent over-healing)
    const dist = Math.sqrt((x - lastHealX) ** 2 + (y - lastHealY) ** 2);
    if (dist < 3) return;
    
    lastHealX = x;
    lastHealY = y;
    healingPoints.push({x, y});
    healBlemish(x, y);
}

function endHealing() {
    isHealing = false;
    healingPoints = [];
    lastHealX = -1;
    lastHealY = -1;
}

function healBlemish(x, y) {
    const ctx = singleImageCtx;
    const radius = blemishBrushSize;
    
    // Get surrounding pixels for context-aware healing
    const surroundRadius = radius * 2.5; // Increased sample area
    const sampleStartX = Math.max(0, Math.floor(x - surroundRadius));
    const sampleStartY = Math.max(0, Math.floor(y - surroundRadius));
    const sampleWidth = Math.min(singleImageCanvas.width - sampleStartX, Math.ceil(surroundRadius * 2));
    const sampleHeight = Math.min(singleImageCanvas.height - sampleStartY, Math.ceil(surroundRadius * 2));
    
    if (sampleWidth <= 0 || sampleHeight <= 0) return;
    
    const imageData = ctx.getImageData(sampleStartX, sampleStartY, sampleWidth, sampleHeight);
    
    // Sample pixels from around the blemish (not at center)
    const samples = [];
    const data = imageData.data;
    const width = imageData.width;
    
    const centerX = x - sampleStartX;
    const centerY = y - sampleStartY;
    
    for (let dy = 0; dy < sampleHeight; dy++) {
        for (let dx = 0; dx < sampleWidth; dx++) {
            const distFromCenter = Math.sqrt((dx - centerX) ** 2 + (dy - centerY) ** 2);
            // Sample from ring around the blemish (not too close, not too far)
            if (distFromCenter > radius * 1.5 && distFromCenter < surroundRadius * 0.8) {
                const idx = (dy * width + dx) * 4;
                samples.push({
                    r: data[idx],
                    g: data[idx + 1],
                    b: data[idx + 2],
                    a: data[idx + 3]
                });
            }
        }
    }
    
    if (samples.length === 0) return;
    
    // Apply healing with VERY soft brush (reduced intensity)
    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist <= radius) {
                const px = Math.floor(x + dx);
                const py = Math.floor(y + dy);
                
                if (px < 0 || px >= singleImageCanvas.width || py < 0 || py >= singleImageCanvas.height) continue;
                
                // MUCH softer brush falloff (cubic for even smoother edges)
                const falloff = 1 - (dist / radius);
                const strength = falloff * falloff * falloff * 0.4; // Reduced from 1.0 to 0.4 for gentler effect
                
                // Get multiple random samples and average them for smoother result
                let avgR = 0, avgG = 0, avgB = 0;
                const numSamples = 3; // Average 3 samples
                for (let i = 0; i < numSamples; i++) {
                    const sample = samples[Math.floor(Math.random() * samples.length)];
                    avgR += sample.r;
                    avgG += sample.g;
                    avgB += sample.b;
                }
                avgR /= numSamples;
                avgG /= numSamples;
                avgB /= numSamples;
                
                // Get current pixel
                const currentData = ctx.getImageData(px, py, 1, 1);
                const current = currentData.data;
                
                // Blend sampled color with current pixel (GENTLER)
                current[0] = Math.floor(current[0] * (1 - strength) + avgR * strength);
                current[1] = Math.floor(current[1] * (1 - strength) + avgG * strength);
                current[2] = Math.floor(current[2] * (1 - strength) + avgB * strength);
                
                ctx.putImageData(currentData, px, py);
            }
        }
    }
}

// ===== CROP TOOL =====
let cropToolActive = false;
let cropOverlay = null;
let cropRect = { x: 50, y: 50, width: 400, height: 400 }; // Default crop area
let isDraggingCrop = false;
let cropDragStartX = 0;
let cropDragStartY = 0;
let dragType = ''; // 'move', 'nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'

function toggleCropTool() {
    if (collageImages.length === 0) {
        showToast('Upload a photo first!', 'warning');
        return;
    }
    
    // Only works in single image mode
    if (collageImages.length > 1) {
        showToast('Crop tool only works with single images', 'info');
        return;
    }
    
    cropToolActive = !cropToolActive;
    const btn = document.getElementById('cropToolBtn');
    
    if (cropToolActive) {
        btn.classList.add('active');
        btn.style.backgroundColor = '#0dcaf0';
        btn.style.color = 'white';
        showCropOverlay();
        showToast('‚úÇÔ∏è Adjust crop area and press Enter to apply, ESC to cancel', 'info');
    } else {
        btn.classList.remove('active');
        btn.style.backgroundColor = '';
        btn.style.color = '';
        hideCropOverlay();
    }
}

function showCropOverlay() {
    // Save state before crop
    saveCanvasState();
    
    // Create overlay container
    const viewer = document.getElementById('singleImageViewer');
    cropOverlay = document.createElement('div');
    cropOverlay.id = 'cropOverlay';
    
    // Get canvas position within viewer
    const viewerRect = viewer.getBoundingClientRect();
    const canvasRect = singleImageCanvas.getBoundingClientRect();
    
    // Calculate canvas position relative to viewer
    const canvasLeft = canvasRect.left - viewerRect.left;
    const canvasTop = canvasRect.top - viewerRect.top;
    const canvasWidth = canvasRect.width;
    const canvasHeight = canvasRect.height;
    
    cropOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 200;
        cursor: move;
        pointer-events: all;
    `;
    
    // Initialize crop rect based on actual canvas position and size
    const margin = Math.min(canvasWidth, canvasHeight) * 0.1; // 10% margin
    cropRect = {
        x: canvasLeft + margin,
        y: canvasTop + margin,
        width: canvasWidth - margin * 2,
        height: canvasHeight - margin * 2
    };
    
    cropOverlay.innerHTML = `
        <svg width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none;">
            <!-- Dimmed area outside crop -->
            <defs>
                <mask id="cropMask">
                    <rect width="100%" height="100%" fill="white"/>
                    <rect id="cropHole" x="${cropRect.x}" y="${cropRect.y}" 
                          width="${cropRect.width}" height="${cropRect.height}" fill="black"/>
                </mask>
            </defs>
            <rect width="100%" height="100%" fill="rgba(0,0,0,0.6)" mask="url(#cropMask)"/>
            
            <!-- Crop frame -->
            <rect id="cropFrame" x="${cropRect.x}" y="${cropRect.y}" 
                  width="${cropRect.width}" height="${cropRect.height}" 
                  fill="none" stroke="#00ffff" stroke-width="2"/>
            
            <!-- Grid lines (rule of thirds) -->
            <line x1="${cropRect.x + cropRect.width/3}" y1="${cropRect.y}" 
                  x2="${cropRect.x + cropRect.width/3}" y2="${cropRect.y + cropRect.height}" 
                  stroke="rgba(255,255,255,0.5)" stroke-width="1"/>
            <line x1="${cropRect.x + cropRect.width*2/3}" y1="${cropRect.y}" 
                  x2="${cropRect.x + cropRect.width*2/3}" y2="${cropRect.y + cropRect.height}" 
                  stroke="rgba(255,255,255,0.5)" stroke-width="1"/>
            <line x1="${cropRect.x}" y1="${cropRect.y + cropRect.height/3}" 
                  x2="${cropRect.x + cropRect.width}" y2="${cropRect.y + cropRect.height/3}" 
                  stroke="rgba(255,255,255,0.5)" stroke-width="1"/>
            <line x1="${cropRect.x}" y1="${cropRect.y + cropRect.height*2/3}" 
                  x2="${cropRect.x + cropRect.width}" y2="${cropRect.y + cropRect.height*2/3}" 
                  stroke="rgba(255,255,255,0.5)" stroke-width="1"/>
            
            <!-- Corner handles (larger, easier to grab) -->
            <circle cx="${cropRect.x}" cy="${cropRect.y}" r="10" fill="#00ffff" stroke="white" stroke-width="2" class="crop-handle" data-handle="nw" style="pointer-events: all; cursor: nw-resize;"/>
            <circle cx="${cropRect.x + cropRect.width}" cy="${cropRect.y}" r="10" fill="#00ffff" stroke="white" stroke-width="2" class="crop-handle" data-handle="ne" style="pointer-events: all; cursor: ne-resize;"/>
            <circle cx="${cropRect.x}" cy="${cropRect.y + cropRect.height}" r="10" fill="#00ffff" stroke="white" stroke-width="2" class="crop-handle" data-handle="sw" style="pointer-events: all; cursor: sw-resize;"/>
            <circle cx="${cropRect.x + cropRect.width}" cy="${cropRect.y + cropRect.height}" r="10" fill="#00ffff" stroke="white" stroke-width="2" class="crop-handle" data-handle="se" style="pointer-events: all; cursor: se-resize;"/>
            
            <!-- Edge handles -->
            <circle cx="${cropRect.x + cropRect.width/2}" cy="${cropRect.y}" r="8" fill="#00ffff" stroke="white" stroke-width="2" class="crop-handle" data-handle="n" style="pointer-events: all; cursor: n-resize;"/>
            <circle cx="${cropRect.x + cropRect.width/2}" cy="${cropRect.y + cropRect.height}" r="8" fill="#00ffff" stroke="white" stroke-width="2" class="crop-handle" data-handle="s" style="pointer-events: all; cursor: s-resize;"/>
            <circle cx="${cropRect.x}" cy="${cropRect.y + cropRect.height/2}" r="8" fill="#00ffff" stroke="white" stroke-width="2" class="crop-handle" data-handle="w" style="pointer-events: all; cursor: w-resize;"/>
            <circle cx="${cropRect.x + cropRect.width}" cy="${cropRect.y + cropRect.height/2}" r="8" fill="#00ffff" stroke="white" stroke-width="2" class="crop-handle" data-handle="e" style="pointer-events: all; cursor: e-resize;"/>
        </svg>
    `;
    
    viewer.appendChild(cropOverlay);
    
    // Add event listeners
    cropOverlay.addEventListener('mousedown', startCropDrag);
    document.addEventListener('mousemove', continueCropDrag);
    document.addEventListener('mouseup', endCropDrag);
    document.addEventListener('keydown', handleCropKeys);
    
    // Handle cursor changes
    cropOverlay.addEventListener('mousemove', updateCropCursor);
}

function hideCropOverlay() {
    if (cropOverlay) {
        cropOverlay.remove();
        cropOverlay = null;
    }
    document.removeEventListener('mousemove', continueCropDrag);
    document.removeEventListener('mouseup', endCropDrag);
    document.removeEventListener('keydown', handleCropKeys);
}

function updateCropCursor(e) {
    const handle = e.target.dataset.handle;
    if (handle) {
        const cursors = {
            'nw': 'nw-resize', 'ne': 'ne-resize', 'sw': 'sw-resize', 'se': 'se-resize',
            'n': 'n-resize', 's': 's-resize', 'e': 'e-resize', 'w': 'w-resize'
        };
        cropOverlay.style.cursor = cursors[handle] || 'move';
    } else {
        // Check if inside crop rect
        const rect = singleImageCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (x >= cropRect.x && x <= cropRect.x + cropRect.width &&
            y >= cropRect.y && y <= cropRect.y + cropRect.height) {
            cropOverlay.style.cursor = 'move';
        } else {
            cropOverlay.style.cursor = 'default';
        }
    }
}

function startCropDrag(e) {
    isDraggingCrop = true;
    const viewerRect = document.getElementById('singleImageViewer').getBoundingClientRect();
    cropDragStartX = e.clientX - viewerRect.left;
    cropDragStartY = e.clientY - viewerRect.top;
    
    const handle = e.target.dataset.handle;
    if (handle) {
        dragType = handle;
    } else {
        // Check if inside crop area
        if (cropDragStartX >= cropRect.x && cropDragStartX <= cropRect.x + cropRect.width &&
            cropDragStartY >= cropRect.y && cropDragStartY <= cropRect.y + cropRect.height) {
            dragType = 'move';
        }
    }
}

function continueCropDrag(e) {
    if (!isDraggingCrop) return;
    
    const viewerRect = document.getElementById('singleImageViewer').getBoundingClientRect();
    const canvasRect = singleImageCanvas.getBoundingClientRect();
    
    const canvasLeft = canvasRect.left - viewerRect.left;
    const canvasTop = canvasRect.top - viewerRect.top;
    const canvasWidth = canvasRect.width;
    const canvasHeight = canvasRect.height;
    
    const x = e.clientX - viewerRect.left;
    const y = e.clientY - viewerRect.top;
    const dx = x - cropDragStartX;
    const dy = y - cropDragStartY;
    
    if (dragType === 'move') {
        cropRect.x += dx;
        cropRect.y += dy;
        
        // Keep within canvas bounds
        cropRect.x = Math.max(canvasLeft, Math.min(canvasLeft + canvasWidth - cropRect.width, cropRect.x));
        cropRect.y = Math.max(canvasTop, Math.min(canvasTop + canvasHeight - cropRect.height, cropRect.y));
    } else if (dragType) {
        // Handle resize
        if (dragType.includes('n')) {
            const newY = cropRect.y + dy;
            const newHeight = cropRect.height - dy;
            if (newHeight > 50) {
                cropRect.y = Math.max(canvasTop, newY);
                cropRect.height = newHeight;
            }
        }
        if (dragType.includes('s')) {
            const maxHeight = canvasTop + canvasHeight - cropRect.y;
            cropRect.height = Math.max(50, Math.min(maxHeight, cropRect.height + dy));
        }
        if (dragType.includes('w')) {
            const newX = cropRect.x + dx;
            const newWidth = cropRect.width - dx;
            if (newWidth > 50) {
                cropRect.x = Math.max(canvasLeft, newX);
                cropRect.width = newWidth;
            }
        }
        if (dragType.includes('e')) {
            const maxWidth = canvasLeft + canvasWidth - cropRect.x;
            cropRect.width = Math.max(50, Math.min(maxWidth, cropRect.width + dx));
        }
        
        // Ensure crop stays within canvas bounds
        cropRect.x = Math.max(canvasLeft, cropRect.x);
        cropRect.y = Math.max(canvasTop, cropRect.y);
        cropRect.width = Math.min(canvasLeft + canvasWidth - cropRect.x, cropRect.width);
        cropRect.height = Math.min(canvasTop + canvasHeight - cropRect.y, cropRect.height);
    }
    
    cropDragStartX = x;
    cropDragStartY = y;
    
    updateCropOverlay();
}

function endCropDrag() {
    isDraggingCrop = false;
    dragType = '';
}

function updateCropOverlay() {
    if (!cropOverlay) return;
    
    const svg = cropOverlay.querySelector('svg');
    svg.querySelector('#cropHole').setAttribute('x', cropRect.x);
    svg.querySelector('#cropHole').setAttribute('y', cropRect.y);
    svg.querySelector('#cropHole').setAttribute('width', cropRect.width);
    svg.querySelector('#cropHole').setAttribute('height', cropRect.height);
    
    svg.querySelector('#cropFrame').setAttribute('x', cropRect.x);
    svg.querySelector('#cropFrame').setAttribute('y', cropRect.y);
    svg.querySelector('#cropFrame').setAttribute('width', cropRect.width);
    svg.querySelector('#cropFrame').setAttribute('height', cropRect.height);
    
    // Update grid lines
    const lines = svg.querySelectorAll('line');
    lines[0].setAttribute('x1', cropRect.x + cropRect.width/3);
    lines[0].setAttribute('x2', cropRect.x + cropRect.width/3);
    lines[0].setAttribute('y1', cropRect.y);
    lines[0].setAttribute('y2', cropRect.y + cropRect.height);
    
    lines[1].setAttribute('x1', cropRect.x + cropRect.width*2/3);
    lines[1].setAttribute('x2', cropRect.x + cropRect.width*2/3);
    lines[1].setAttribute('y1', cropRect.y);
    lines[1].setAttribute('y2', cropRect.y + cropRect.height);
    
    lines[2].setAttribute('x1', cropRect.x);
    lines[2].setAttribute('x2', cropRect.x + cropRect.width);
    lines[2].setAttribute('y1', cropRect.y + cropRect.height/3);
    lines[2].setAttribute('y2', cropRect.y + cropRect.height/3);
    
    lines[3].setAttribute('x1', cropRect.x);
    lines[3].setAttribute('x2', cropRect.x + cropRect.width);
    lines[3].setAttribute('y1', cropRect.y + cropRect.height*2/3);
    lines[3].setAttribute('y2', cropRect.y + cropRect.height*2/3);
    
    // Update handles
    const handles = svg.querySelectorAll('.crop-handle');
    handles[0].setAttribute('cx', cropRect.x);
    handles[0].setAttribute('cy', cropRect.y);
    handles[1].setAttribute('cx', cropRect.x + cropRect.width);
    handles[1].setAttribute('cy', cropRect.y);
    handles[2].setAttribute('cx', cropRect.x);
    handles[2].setAttribute('cy', cropRect.y + cropRect.height);
    handles[3].setAttribute('cx', cropRect.x + cropRect.width);
    handles[3].setAttribute('cy', cropRect.y + cropRect.height);
    handles[4].setAttribute('cx', cropRect.x + cropRect.width/2);
    handles[4].setAttribute('cy', cropRect.y);
    handles[5].setAttribute('cx', cropRect.x + cropRect.width/2);
    handles[5].setAttribute('cy', cropRect.y + cropRect.height);
    handles[6].setAttribute('cx', cropRect.x);
    handles[6].setAttribute('cy', cropRect.y + cropRect.height/2);
    handles[7].setAttribute('cx', cropRect.x + cropRect.width);
    handles[7].setAttribute('cy', cropRect.y + cropRect.height/2);
}

function handleCropKeys(e) {
    if (!cropToolActive) return;
    
    if (e.key === 'Enter') {
        applyCrop();
    } else if (e.key === 'Escape') {
        toggleCropTool();
    }
}

function applyCrop() {
    // Get canvas position relative to viewer
    const viewerRect = document.getElementById('singleImageViewer').getBoundingClientRect();
    const canvasRect = singleImageCanvas.getBoundingClientRect();
    
    const canvasLeft = canvasRect.left - viewerRect.left;
    const canvasTop = canvasRect.top - viewerRect.top;
    
    // Calculate crop coordinates relative to canvas
    const cropXRelative = cropRect.x - canvasLeft;
    const cropYRelative = cropRect.y - canvasTop;
    
    // Scale to actual canvas pixels
    const scaleX = singleImageCanvas.width / canvasRect.width;
    const scaleY = singleImageCanvas.height / canvasRect.height;
    
    const cropX = Math.max(0, Math.floor(cropXRelative * scaleX));
    const cropY = Math.max(0, Math.floor(cropYRelative * scaleY));
    const cropW = Math.min(singleImageCanvas.width - cropX, Math.floor(cropRect.width * scaleX));
    const cropH = Math.min(singleImageCanvas.height - cropY, Math.floor(cropRect.height * scaleY));
    
    if (cropW <= 0 || cropH <= 0) {
        showToast('Invalid crop area', 'error');
        return;
    }
    
    // Get the cropped image data
    const croppedData = singleImageCtx.getImageData(cropX, cropY, cropW, cropH);
    
    // Resize canvas to cropped size
    singleImageCanvas.width = cropW;
    singleImageCanvas.height = cropH;
    
    // Draw cropped image
    singleImageCtx.putImageData(croppedData, 0, 0);
    
    // Update the original image
    const croppedImage = new Image();
    croppedImage.onload = function() {
        collageImages[0] = croppedImage;
        
        // Save to cache only (not history - history is for uploaded images only)
        const imageDataURLs = [croppedImage.src];
        saveImageToCache(imageDataURLs, 'collage');
        
        // Clear history and save new state
        canvasHistory = [];
        saveCanvasState();
        
        showToast('‚úÇÔ∏è Image cropped successfully!', 'success');
        toggleCropTool();
    };
    croppedImage.src = singleImageCanvas.toDataURL('image/png');
}

// ===== IMAGE ENHANCEMENT =====
async function enhanceImage() {
    if (collageImages.length === 0) {
        showToast('Upload a photo first!', 'warning');
        return;
    }
    
    // Only works in single image mode
    if (collageImages.length > 1) {
        showToast('Enhance tool only works with single images', 'info');
        return;
    }
    
    const btn = document.getElementById('enhanceBtn');
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Enhancing...';
    
    try {
        // Save state before enhancement
        saveCanvasState();
        
        // Convert canvas to blob
        const blob = await new Promise(resolve => {
            singleImageCanvas.toBlob(resolve, 'image/png');
        });
        
        // Create FormData
        const formData = new FormData();
        formData.append('image', blob, 'image.png');
        
        // Call enhancement API
        const response = await fetch('/image/api/enhance_web_image', {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            throw new Error('Enhancement failed');
        }
        
        // Get enhanced image
        const enhancedBlob = await response.blob();
        const enhancedURL = URL.createObjectURL(enhancedBlob);
        
        // Load and display enhanced image
        const enhancedImg = new Image();
        enhancedImg.onload = function() {
            // Update canvas
            singleImageCanvas.width = enhancedImg.width;
            singleImageCanvas.height = enhancedImg.height;
            singleImageCtx.clearRect(0, 0, singleImageCanvas.width, singleImageCanvas.height);
            singleImageCtx.drawImage(enhancedImg, 0, 0);
            
            // Update collage images array
            collageImages[0] = enhancedImg;
            
            // Save to cache
            const imageDataURLs = [singleImageCanvas.toDataURL('image/png')];
            saveImageToCache(imageDataURLs, 'collage');
            
            // Save new state for undo
            saveCanvasState();
            
            // Clean up
            URL.revokeObjectURL(enhancedURL);
            
            showToast('‚ú® Image enhanced successfully!', 'success');
        };
        enhancedImg.onerror = function() {
            throw new Error('Failed to load enhanced image');
        };
        enhancedImg.src = enhancedURL;
        
    } catch (error) {
        console.error('Enhancement error:', error);
        showToast('Enhancement failed: ' + error.message, 'danger');
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<i class="bi bi-stars me-1"></i>Enhance';
    }
}

// ===== LOCKED DRAG WITH OBJECT-POSITION =====
function bindLockedDrag(img, imageIndex) {
    if (!img) return;
    img.setAttribute('draggable', 'false');  // ch·∫∑n drag m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát
    img.style.cursor = 'grab';

    let dragging = false;
    let startX = 0, startY = 0;
    let startPosX = 50, startPosY = 50; // object-position ban ƒë·∫ßu (%)

    img.addEventListener('pointerdown', (e) => {
        // Don't allow dragging if locked (editing text)
        if (isImageDraggingLocked) {
            console.log('‚õî Image drag blocked - text editing in progress');
            return;
        }
        
        dragging = true;
        startX = e.clientX;
        startY = e.clientY;
        
        // L·∫•y object-position hi·ªán t·∫°i
        const pos = img.style.objectPosition || '50% 50%';
        const [px, py] = pos.split(' ').map(s => parseFloat(s));
        startPosX = px;
        startPosY = py;
        
        if (img.setPointerCapture) {
            img.setPointerCapture(e.pointerId);
        }
        img.style.cursor = 'grabbing';
        e.preventDefault();
    }, { passive: false });

    img.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        
        const rect = img.getBoundingClientRect();
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        // Chuy·ªÉn delta pixel sang % d·ª±a tr√™n k√≠ch th∆∞·ªõc tile
        const deltaXPercent = (deltaX / rect.width) * 100;
        const deltaYPercent = (deltaY / rect.height) * 100;
        
        // T√≠nh v·ªã tr√≠ m·ªõi (k√©o chu·ªôt ph·∫£i = ·∫£nh sang ph·∫£i, k√©o l√™n = ·∫£nh l√™n)
        let newX = startPosX + deltaXPercent;
        let newY = startPosY + deltaYPercent;
        
        // Clamp 0‚Äì100% ƒë·ªÉ kh√¥ng bao gi·ªù h·ªü n·ªÅn
        newX = Math.max(0, Math.min(100, newX));
        newY = Math.max(0, Math.min(100, newY));
        
        img.style.objectPosition = `${newX}% ${newY}%`;
        
        // Save to imagePositions array for persistence
        if (imageIndex !== undefined) {
            imagePositions[imageIndex] = { x: newX, y: newY };
        }
        
        e.preventDefault();
    }, { passive: false });

    const end = () => { 
        dragging = false; 
        img.style.cursor = 'grab'; 
    };
    img.addEventListener('pointerup', end);
    img.addEventListener('pointercancel', end);
}

// ===== HELPER FUNCTIONS FOR CANVAS COLLAGE =====
// Preload ·∫£nh: tr·∫£ v·ªÅ HTMLImageElement ƒë√£ s·∫µn s√†ng
async function loadImage(src) {
    return new Promise((res, rej) => {
        const im = new Image();
        im.crossOrigin = "anonymous";
        im.onload = () => res(im);
        im.onerror = rej;
        im.src = src;
    });
}

// T√≠nh danh s√°ch cell theo layout cho 3 ·∫£nh
// Tr·∫£ v·ªÅ m·∫£ng c√°c rect: [{x,y,w,h}, ...] (t·ªça ƒë·ªô pixel trong canvas)
function getCellsForLayout(layoutKey, W, H, gutter) {
    const g = gutter;
    // M·∫∑c ƒë·ªãnh: 1 ·∫£nh b√™n ph·∫£i full height, 2 ·∫£nh b√™n tr√°i chia ƒë√¥i
    // ƒê·∫∑t t√™n v√≠ d·ª•: 'L2_R1' (2 tr√°i 1 ph·∫£i), 'R2_L1', 'T2_B1' (2 tr√™n 1 d∆∞·ªõi), ...
    switch (layoutKey) {
        case 'L2_R1':
        case 'layout-3-left': {
            const colW = Math.floor((W - g) / 2);
            const rightW = W - g - colW;
            const halfH = Math.floor((H - g) / 2);
            return [
                { x: 0,        y: 0,      w: colW, h: halfH },        // left-top
                { x: 0,        y: halfH+g,w: colW, h: H - halfH - g },// left-bottom
                { x: colW+g,   y: 0,      w: rightW, h: H }           // right full
            ];
        }
        case 'R2_L1':
        case 'layout-3-right': {
            const colW = Math.floor((W - g) / 2);
            const leftW = W - g - colW;
            const halfH = Math.floor((H - g) / 2);
            return [
                { x: 0,        y: 0,      w: leftW, h: H },           // left full
                { x: leftW+g,  y: 0,      w: colW, h: halfH },        // right-top
                { x: leftW+g,  y: halfH+g,w: colW, h: H - halfH - g } // right-bottom
            ];
        }
        case 'T2_B1':
        case 'layout-3-top': {
            const rowH = Math.floor((H - g) / 2);
            const topH = rowH, botH = H - g - rowH;
            const halfW = Math.floor((W - g) / 2);
            return [
                { x: 0,      y: 0,     w: halfW,   h: topH },         // top-left
                { x: halfW+g,y: 0,     w: W - halfW - g, h: topH },   // top-right
                { x: 0,      y: topH+g,w: W,       h: botH }          // bottom full
            ];
        }
        case 'B2_T1':
        case 'layout-3-bottom': {
            const rowH = Math.floor((H - g) / 2);
            const topH = H - g - rowH, botH = rowH;
            const halfW = Math.floor((W - g) / 2);
            return [
                { x: 0,      y: 0,     w: W,       h: topH },         // top full
                { x: 0,      y: topH+g,w: halfW,   h: botH },         // bottom-left
                { x: halfW+g,y: topH+g,w: W - halfW - g, h: botH }    // bottom-right
            ];
        }
        case 'layout-3h':
        case 'layout-3-horizontal':
        default: { // 3 c·ªôt (fallback)
            const colW = Math.floor((W - 2*g)/3);
            return [
                { x: 0,         y: 0, w: colW,     h: H },
                { x: colW+g,    y: 0, w: colW,     h: H },
                { x: 2*(colW+g),y: 0, w: W - 2*(colW+g) - colW, h: H }
            ];
        }
    }
}

// Clamp offset ƒë·ªÉ kh√¥ng bao gi·ªù h·ªü n·ªÅn (cover logic)
function clampOffsetForCover(imgW, imgH, cellW, cellH, off) {
    const imgAspect = imgW / imgH;
    const cellAspect = cellW / cellH;

    // K√≠ch th∆∞·ªõc v·∫Ω theo cover
    let drawW, drawH;
    if (imgAspect > cellAspect) {
        drawH = cellH;
        drawW = Math.ceil(cellH * imgAspect);
    } else {
        drawW = cellW;
        drawH = Math.ceil(cellW / imgAspect);
    }
    // Ph·∫ßn "d∆∞" ƒë·ªÉ c√≥ th·ªÉ pan m√† v·∫´n cover
    const overflowX = Math.max(0, drawW - cellW);
    const overflowY = Math.max(0, drawH - cellH);

    return {
        x: Math.min( overflowX/2, Math.max(-overflowX/2, off.x || 0) ),
        y: Math.min( overflowY/2, Math.max(-overflowY/2, off.y || 0) ),
        drawW, drawH
    };
}

// ===== PHOTO COLLAGE TAB VARIABLES =====
let collageCanvas = document.getElementById('collageCanvas');
let collageCtx = collageCanvas.getContext('2d');
let collageImages = [];
let selectedLayout = null;

// Image position offsets for manual adjustment
let imageOffsets = []; // Array of {x: 0, y: 0} for each image

// Store object-position for each image (to persist across re-renders)
let imagePositions = []; // Array of {x: 50, y: 50} (percentage)

// Current images and layout for canvas redraw
let currentImages = [];
let currentLayoutKey = null;

// Drag state
let isDragging = false;
let dragImageIndex = -1;
let dragStartX = 0;
let dragStartY = 0;
let dragInitialOffsetX = 0;
let dragInitialOffsetY = 0;

// Layout templates definitions - [col, row, colSpan, rowSpan]
const layoutTemplates = [
    // === 1 PHOTO ===
    { id: 'layout-1', name: '1 photo', cols: 1, rows: 1, maxPhotos: 1, cells: [[0,0,1,1]] },
    
    // === 2 PHOTOS ===
    { id: 'layout-2h', name: '2 horizontal', cols: 2, rows: 1, maxPhotos: 2, cells: [[0,0,1,1], [1,0,1,1]] },
    { id: 'layout-2v', name: '2 vertical', cols: 1, rows: 2, maxPhotos: 2, cells: [[0,0,1,1], [0,1,1,1]] },
    
    // === 3 PHOTOS ===
    { id: 'layout-3h', name: '3 horizontal', cols: 3, rows: 1, maxPhotos: 3, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1]] },
    { id: 'layout-3v', name: '3 vertical', cols: 1, rows: 3, maxPhotos: 3, cells: [[0,0,1,1], [0,1,1,1], [0,2,1,1]] },
    { id: 'layout-3-left', name: '3 left large', cols: 2, rows: 2, maxPhotos: 3, cells: [[0,0,1,2], [1,0,1,1], [1,1,1,1]] },
    { id: 'layout-3-right', name: '3 right large', cols: 2, rows: 2, maxPhotos: 3, cells: [[0,0,1,1], [0,1,1,1], [1,0,1,2]] },
    { id: 'layout-3-top', name: '3 top large', cols: 2, rows: 2, maxPhotos: 3, cells: [[0,0,2,1], [0,1,1,1], [1,1,1,1]] },
    { id: 'layout-3-bottom', name: '3 bottom large', cols: 2, rows: 2, maxPhotos: 3, cells: [[0,0,1,1], [1,0,1,1], [0,1,2,1]] },
    
    // === 4 PHOTOS ===
    { id: 'layout-4-grid', name: '4 grid 2√ó2', cols: 2, rows: 2, maxPhotos: 4, cells: [[0,0,1,1], [1,0,1,1], [0,1,1,1], [1,1,1,1]] },
    { id: 'layout-4h', name: '4 horizontal', cols: 4, rows: 1, maxPhotos: 4, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1], [3,0,1,1]] },
    { id: 'layout-4v', name: '4 vertical', cols: 1, rows: 4, maxPhotos: 4, cells: [[0,0,1,1], [0,1,1,1], [0,2,1,1], [0,3,1,1]] },
    { id: 'layout-4-left', name: '4 left large', cols: 2, rows: 3, maxPhotos: 4, cells: [[0,0,1,3], [1,0,1,1], [1,1,1,1], [1,2,1,1]] },
    { id: 'layout-4-right', name: '4 right large', cols: 2, rows: 3, maxPhotos: 4, cells: [[0,0,1,1], [0,1,1,1], [0,2,1,1], [1,0,1,3]] },
    { id: 'layout-4-top', name: '4 top large', cols: 3, rows: 2, maxPhotos: 4, cells: [[0,0,3,1], [0,1,1,1], [1,1,1,1], [2,1,1,1]] },
    { id: 'layout-4-bottom', name: '4 bottom large', cols: 3, rows: 2, maxPhotos: 4, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1], [0,1,3,1]] },
    { id: 'layout-4-center', name: '4 center large', cols: 3, rows: 3, maxPhotos: 4, cells: [[0,0,1,1], [2,0,1,1], [1,1,1,1], [0,2,1,1]] },
    
    // === 5 PHOTOS ===
    { id: 'layout-5h', name: '5 horizontal', cols: 5, rows: 1, maxPhotos: 5, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1], [3,0,1,1], [4,0,1,1]] },
    { id: 'layout-5v', name: '5 vertical', cols: 1, rows: 5, maxPhotos: 5, cells: [[0,0,1,1], [0,1,1,1], [0,2,1,1], [0,3,1,1], [0,4,1,1]] },
    { id: 'layout-5-left', name: '5 left large', cols: 3, rows: 2, maxPhotos: 5, cells: [[0,0,1,2], [1,0,1,1], [2,0,1,1], [1,1,1,1], [2,1,1,1]] },
    { id: 'layout-5-right', name: '5 right large', cols: 3, rows: 2, maxPhotos: 5, cells: [[0,0,1,1], [1,0,1,1], [0,1,1,1], [1,1,1,1], [2,0,1,2]] },
    { id: 'layout-5-top2', name: '5 top 2', cols: 3, rows: 2, maxPhotos: 5, cells: [[0,0,2,1], [2,0,1,1], [0,1,1,1], [1,1,1,1], [2,1,1,1]] },
    { id: 'layout-5-top3', name: '5 top 3', cols: 3, rows: 2, maxPhotos: 5, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1], [0,1,2,1], [2,1,1,1]] },
    { id: 'layout-5-center', name: '5 center large', cols: 3, rows: 3, maxPhotos: 5, cells: [[0,0,1,1], [2,0,1,1], [1,1,1,1], [0,2,1,1], [2,2,1,1]] },
    { id: 'layout-5-grid', name: '5 grid mixed', cols: 3, rows: 2, maxPhotos: 5, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1], [0,1,1,1], [1,1,2,1]] },
    
    // === 6 PHOTOS ===
    { id: 'layout-6-grid', name: '6 grid 2√ó3', cols: 3, rows: 2, maxPhotos: 6, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1], [0,1,1,1], [1,1,1,1], [2,1,1,1]] },
    { id: 'layout-6h', name: '6 horizontal', cols: 6, rows: 1, maxPhotos: 6, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1], [3,0,1,1], [4,0,1,1], [5,0,1,1]] },
    { id: 'layout-6v', name: '6 vertical', cols: 1, rows: 6, maxPhotos: 6, cells: [[0,0,1,1], [0,1,1,1], [0,2,1,1], [0,3,1,1], [0,4,1,1], [0,5,1,1]] },
    
    // === 9 PHOTOS ===
    { id: 'layout-9-grid', name: '9 grid 3√ó3', cols: 3, rows: 3, maxPhotos: 9, cells: [[0,0,1,1], [1,0,1,1], [2,0,1,1], [0,1,1,1], [1,1,1,1], [2,1,1,1], [0,2,1,1], [1,2,1,1], [2,2,1,1]] }
];

// Update slider values display and trigger collage update
document.getElementById('collageGutter').addEventListener('input', function(e) {
    document.getElementById('gutterValue2').textContent = e.target.value;
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

document.getElementById('collageRadius').addEventListener('input', function(e) {
    document.getElementById('radiusValue2').textContent = e.target.value;
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

document.getElementById('collageBorder').addEventListener('input', function(e) {
    document.getElementById('borderValue2').textContent = e.target.value;
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

// Auto-update collage when settings change
document.getElementById('collageAspect').addEventListener('change', function() {
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

document.getElementById('collageBorderColor').addEventListener('change', function() {
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

document.getElementById('collageBackground').addEventListener('change', function() {
    if (selectedLayout && collageImages.length > 0) {
        createCollageWithLayout();
    }
});

// Render layout templates
function renderLayoutTemplates() {
    const container = document.getElementById('layoutTemplates');
    const panel = document.getElementById('templatesPanel');
    
    // Show/hide panel based on uploaded photos
    if (collageImages.length === 0) {
        panel.style.display = 'none';
        return;
    }
    
    panel.style.display = 'block';
    let html = '';
    
    // Filter templates: only show templates matching uploaded photo count
    const availableTemplates = layoutTemplates.filter(layout => layout.maxPhotos === collageImages.length);
    
    if (availableTemplates.length === 0) {
        html = `<div class="text-center text-muted p-2 w-100" style="font-size: 0.85rem;">
                    <i class="bi bi-info-circle"></i> No layouts for ${collageImages.length} photos
                </div>`;
        container.innerHTML = html;
        return;
    }
    
    availableTemplates.forEach(layout => {
        // Smaller size for sidebar
        const svgSize = 60;
        const maxDim = Math.max(layout.cols, layout.rows);
        const scale = svgSize / maxDim;
        const svgWidth = layout.cols * scale;
        const svgHeight = layout.rows * scale;
        
        html += `
            <div class="layout-template ${selectedLayout === layout.id ? 'selected' : ''}" 
                 onclick="selectLayout('${layout.id}')"
                 title="${layout.name} (${layout.maxPhotos} photo${layout.maxPhotos > 1 ? 's' : ''})"
                 style="cursor: pointer; padding: 8px; border: 2px solid ${selectedLayout === layout.id ? '#0d6efd' : '#495057'}; border-radius: 4px; background: #212529; transition: all 0.2s;">
                <svg viewBox="0 0 ${layout.cols * 100} ${layout.rows * 100}" 
                     width="${svgWidth}" 
                     height="${svgHeight}"
                     style="display: block; margin: 0 auto;">
                    ${layout.cells.map(cell => {
                        const [x, y, w, h] = cell;
                        const cellX = x * 100;
                        const cellY = y * 100;
                        const cellW = w * 100;
                        const cellH = h * 100;
                        return `<rect x="${cellX + 3}" y="${cellY + 3}" width="${cellW - 6}" height="${cellH - 6}" 
                                     fill="#495057" 
                                     stroke="#6c757d" 
                                     stroke-width="3"
                                     rx="5" ry="5"/>`;
                    }).join('')}
                </svg>
                <small class="d-block text-center mt-1" style="font-size: 0.65rem; color: #adb5bd;">${layout.name}</small>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

function selectLayout(layoutId) {
    const layout = layoutTemplates.find(l => l.id === layoutId);
    if (!layout) return;
    
    selectedLayout = layoutId;
    renderLayoutTemplates();
    
    if (collageImages.length > 0) {
        createCollageWithLayout();
    }
}

document.getElementById('collageUpload').addEventListener('change', function(e) {
    const files = Array.from(e.target.files);
    if (files.length === 0) return;
    
    collageImages = [];
    imageOffsets = [];
    imagePositions = []; // Reset saved positions
    const previewContainer = document.getElementById('uploadedPhotosPreview');
    previewContainer.innerHTML = '';
    
    const imageDataURLs = []; // Store for caching
    let loadedCount = 0;
    
    files.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                collageImages.push(img);
                imageDataURLs.push(event.target.result); // Save dataURL
                loadedCount++;
                
                // Add thumbnail to preview
                const col = document.createElement('div');
                col.className = 'col-auto';
                col.innerHTML = `
                    <div class="position-relative" style="width: 80px; height: 80px;">
                        <img src="${event.target.result}" 
                             class="img-thumbnail" 
                             style="width: 100%; height: 100%; object-fit: cover;">
                    </div>
                `;
                previewContainer.appendChild(col);
                
                if (loadedCount === files.length) {
                    document.getElementById('collagePrompt').style.display = 'none';
                    
                    // Check if single image mode
                    if (files.length === 1) {
                        // Single image viewer mode
                        showSingleImageViewer(collageImages[0]);
                        showToast('1 photo uploaded - Single viewer mode', 'success');
                    } else {
                        // Collage mode (2+ images)
                        previewContainer.style.display = 'flex';
                        showToast(`${files.length} photos uploaded`, 'success');
                        
                        // Re-render templates to show only matching photo count
                        renderLayoutTemplates();
                        
                        // Auto-select first matching layout
                        const matchingLayout = layoutTemplates.find(l => l.maxPhotos === files.length);
                        if (matchingLayout) {
                            selectLayout(matchingLayout.id);
                        }
                    }
                    
                    // Save to cache
                    saveImageToCache(imageDataURLs, 'collage');
                    
                    // Auto-save to history
                    saveToHistory(imageDataURLs);
                }
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });
});

// ==== CREATE HTML COLLAGE WITH CSS GRID (SUPPORTS ALL LAYOUTS) ====
function createHTMLCollage() {
    const gutter = parseInt(document.getElementById('collageGutter').value);
    const radius = parseInt(document.getElementById('collageRadius').value);
    const borderWidth = parseInt(document.getElementById('collageBorder').value);
    const borderColor = document.getElementById('collageBorderColor').value;
    const backgroundColor = document.getElementById('collageBackground').value;
    
    const collageTiles = document.getElementById('collage-tiles');
    
    // Get current layout
    const layout = layoutTemplates.find(l => l.id === selectedLayout);
    if (!layout) return;
    
    // --- Get aspect ratio from selector ---
    const aspect = document.getElementById('collageAspect').value;
    const [arW, arH] = aspect.split(':').map(Number);

    // --- Calculate height based on actual width of #collage-tiles ---
    const tiles = document.getElementById('collage-tiles');
    const maxW = tiles.parentElement.clientWidth;
    const innerW = Math.max(320, maxW - gutter*2);
    const innerH = Math.round(innerW * arH / arW);

    // Set CSS variables for responsive styling
    tiles.style.setProperty('--canvas-h', `${innerH}px`);
    tiles.style.aspectRatio = `${arW} / ${arH}`;
    collageTiles.style.setProperty('--gutter', `${gutter}px`);
    collageTiles.style.setProperty('--radius', `${radius}px`);
    collageTiles.style.setProperty('--stroke', `${borderWidth}px`);
    collageTiles.style.setProperty('--stroke-color', borderColor);
    
    // Apply background
    collageTiles.style.backgroundColor = backgroundColor;
    collageTiles.style.padding = `${gutter}px`;
    
    // Clear existing tiles
    collageTiles.innerHTML = '';
    
    // Set up CSS Grid based on layout
    collageTiles.style.display = 'grid';
    collageTiles.style.gridTemplateColumns = `repeat(${layout.cols}, 1fr)`;
    collageTiles.style.gridTemplateRows = `repeat(${layout.rows}, 1fr)`;
    collageTiles.style.gap = `${gutter}px`;
    
    // Create tiles based on layout cells
    layout.cells.forEach((cell, index) => {
        if (index >= collageImages.length) return; // Don't create tile if no image
        
        const [col, row, colSpan, rowSpan] = cell;
        
        // Create tile container
        const tileDiv = document.createElement('div');
        tileDiv.className = 'tile';
        tileDiv.style.gridColumn = `${col + 1} / span ${colSpan}`;
        tileDiv.style.gridRow = `${row + 1} / span ${rowSpan}`;
        tileDiv.style.overflow = 'hidden';
        tileDiv.style.borderRadius = `${radius}px`;
        tileDiv.style.border = borderWidth > 0 ? `${borderWidth}px solid ${borderColor}` : 'none';
        tileDiv.style.position = 'relative';
        
        // Create image
        const img = document.createElement('img');
        img.src = collageImages[index].src;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        
        // Restore saved position or use default
        if (imagePositions[index]) {
            img.style.objectPosition = `${imagePositions[index].x}% ${imagePositions[index].y}%`;
        } else {
            img.style.objectPosition = '50% 50%';
            // Initialize position in array
            imagePositions[index] = { x: 50, y: 50 };
        }
        
        img.style.pointerEvents = 'auto';
        img.style.userSelect = 'none';
        img.style.display = 'block';
        
        tileDiv.appendChild(img);
        collageTiles.appendChild(tileDiv);
        
        // Bind drag functionality with index
        bindLockedDrag(img, index);
    });
    
    // Hide canvas, show tiles
    document.getElementById('collageCanvasContainer').style.display = 'none';
    document.getElementById('uploadedPhotosPreview').style.display = 'none';
    document.getElementById('collagePrompt').style.display = 'none';
    collageTiles.style.display = 'grid';
}

// Apply UI settings
function applyUI() {
    if (selectedLayout && collageImages.length > 0) {
        createHTMLCollage();
    }
}

function createCollageWithLayout() {
    if (collageImages.length === 0 || !selectedLayout) {
        showToast('Please upload photos and select a layout', 'warning');
        return;
    }
    
    const layout = layoutTemplates.find(l => l.id === selectedLayout);
    if (!layout) return;
    
    // ===== USE HTML/CSS GRID FOR ALL LAYOUTS =====
    // HTML tiles work perfectly for all layouts (2, 3, 4, 9 photos)
    createHTMLCollage();
}

// New async canvas collage function
async function createCanvasCollage(images, layoutKey) {
    // Save for drag redraw
    currentImages = images;
    currentLayoutKey = layoutKey;
    
    // 1) K√≠ch th∆∞·ªõc canvas theo t·ª∑ l·ªá ch·ªçn
    const aspect = document.getElementById('collageAspect').value; // '1:1','3:4','4:5','16:9'
    const [arW, arH] = aspect.split(':').map(Number);
    const base = 1080; // c·∫°nh d√†i ƒë·ªÉ xu·∫•t n√©t
    const CW = arW >= arH ? base : Math.round(base * (arW/arH));
    const CH = arH >= arW ? base : Math.round(base * (arH/arW));

    collageCanvas.width  = CW;
    collageCanvas.height = CH;

    const gutter = parseInt(document.getElementById('collageGutter').value || 0, 10);
    const radius = parseInt(document.getElementById('collageRadius').value || 0, 10);
    const border = parseInt(document.getElementById('collageBorder').value || 0, 10);
    const borderColor = document.getElementById('collageBorderColor').value || '#ff3b30';
    const backgroundColor = document.getElementById('collageBackground').value || '#111111';

    // 2) Preload ·∫£nh (fix l·ªói "ch·ªâ 1 ·∫£nh")
    const imgs = await Promise.all(images.map(src => loadImage(src)));

    // 3) T√≠nh cell theo layout
    const cells = getCellsForLayout(layoutKey, CW, CH, gutter);
    // n·∫øu s·ªë cell √≠t h∆°n s·ªë ·∫£nh, ch·ªâ l·∫•y ·∫£nh ƒë·∫ßu; n·∫øu nhi·ªÅu h∆°n th√¨ l·∫∑p l·∫°i ·∫£nh cu·ªëi
    const n = Math.min(cells.length, imgs.length);

    collageCtx.clearRect(0,0,CW,CH);
    
    // Fill background
    collageCtx.fillStyle = backgroundColor;
    collageCtx.fillRect(0, 0, CW, CH);

    for (let i = 0; i < n; i++) {
        const {x,y,w,h} = cells[i];
        const im = imgs[i];

        // 3a) chu·∫©n b·ªã cover + clamp offset
        const offRaw = imageOffsets[i] || {x:0,y:0};
        const {x:offX, y:offY, drawW, drawH} = clampOffsetForCover(im.width, im.height, w, h, offRaw);

        // 3b) to·∫° ƒë·ªô v·∫Ω sao cho ·∫£nh v·∫´n cover cell
        const drawX = x + Math.round((w - drawW)/2 + offX);
        const drawY = y + Math.round((h - drawH)/2 + offY);

        // 3c) clip tr√≤n g√≥c + v·∫Ω
        collageCtx.save();
        if (radius > 0) {
            const r = Math.min(radius, Math.min(w,h)/2 - 1);
            const p = new Path2D();
            p.moveTo(x+r,y);
            p.arcTo(x+w,y,x+w,y+h,r);
            p.arcTo(x+w,y+h,x,y+h,r);
            p.arcTo(x,y+h,x,y,r);
            p.arcTo(x,y,x+w,y,r);
            p.closePath();
            collageCtx.clip(p);
        } else {
            collageCtx.beginPath();
            collageCtx.rect(x,y,w,h);
            collageCtx.clip();
        }

        collageCtx.drawImage(im, drawX, drawY, drawW, drawH);
        collageCtx.restore();

        // 3d) Border cell (v·∫Ω ƒë√∫ng n√©t, kh√¥ng *2)
        if (border > 0) {
            collageCtx.save();
            collageCtx.lineWidth = border;
            collageCtx.strokeStyle = borderColor;
            const inset = border/2;
            collageCtx.beginPath();
            if (radius > 0) {
                const r = Math.max(0, Math.min(radius - inset, Math.min(w,h)/2 - inset));
                const p2 = new Path2D();
                p2.moveTo(x+inset+r, y+inset);
                p2.arcTo(x+w-inset, y+inset,   x+w-inset, y+h-inset, r);
                p2.arcTo(x+w-inset, y+h-inset, x+inset,   y+h-inset, r);
                p2.arcTo(x+inset,   y+h-inset, x+inset,   y+inset,   r);
                p2.arcTo(x+inset,   y+inset,   x+w-inset, y+inset,   r);
                p2.closePath();
                collageCtx.stroke(p2);
            } else {
                collageCtx.strokeRect(x+inset, y+inset, w-border, h-border);
            }
            collageCtx.restore();
        }
    }

    // 4) G·∫Øn v√πng drag cho t·ª´ng cell (pan trong gi·ªõi h·∫°n)
    enableCanvasDrag(cells);
    
    // Show canvas container
    document.getElementById('uploadedPhotosPreview').style.display = 'none';
    document.getElementById('collageCanvasContainer').style.display = 'block';
    document.getElementById('collage-tiles').style.display = 'none';
}

// K√©o trong Canvas ‚Äì kh√¥ng bao gi·ªù l√≤i n·ªÅn
function enableCanvasDrag(cells) {
    let active = -1;
    let start = {x:0, y:0};
    
    collageCanvas.onpointerdown = (e) => {
        const rect = collageCanvas.getBoundingClientRect();
        const cx = (e.clientX - rect.left) * (collageCanvas.width / rect.width);
        const cy = (e.clientY - rect.top)  * (collageCanvas.height / rect.height);
        // ch·ªçn cell ƒëang click
        active = cells.findIndex(({x,y,w,h}) => cx>=x && cx<=x+w && cy>=y && cy<=y+h);
        start = {x:cx, y:cy};
        if (collageCanvas.setPointerCapture) {
            collageCanvas.setPointerCapture(e.pointerId);
        }
    };
    
    collageCanvas.onpointermove = (e) => {
        if (active < 0) return;
        const rect = collageCanvas.getBoundingClientRect();
        const cx = (e.clientX - rect.left) * (collageCanvas.width / rect.width);
        const cy = (e.clientY - rect.top)  * (collageCanvas.height / rect.height);
        const dx = cx - start.x, dy = cy - start.y;
        start = {x:cx, y:cy};
        imageOffsets[active] = imageOffsets[active] || {x:0, y:0};
        imageOffsets[active].x += dx;
        imageOffsets[active].y += dy;

        // v·∫Ω l·∫°i (clamp s·∫Ω √°p trong createCanvasCollage)
        if (currentImages && currentLayoutKey) {
            createCanvasCollage(currentImages, currentLayoutKey);
        }
    };
    
    const end = () => { active = -1; };
    collageCanvas.onpointerup = end;
    collageCanvas.onpointercancel = end;
}

// ========== TEXT LAYER FUNCTIONS ==========
let textLayers = [];
let currentEditingLayer = null;
let textLayerCounter = 0;
let selectedTextRange = null;

function toggleTextLayer() {
    if (collageImages.length === 0) {
        showToast('Upload photos first!', 'warning');
        return;
    }
    createNewTextLayer();
}

function createNewTextLayer() {
    textLayerCounter++;
    const layerId = `textLayer_${textLayerCounter}`;
    
    const textLayer = {
        id: layerId,
        text: 'Double click to edit',
        color: '#ffffff',
        rainbow: false,
        fontFamily: 'Arial',
        x: 50, // percentage
        y: 50, // percentage
        fontSize: 32
    };
    
    textLayers.push(textLayer);
    renderTextLayer(textLayer, false); // false = don't auto edit, let user double-click
    
    // Show helpful hint on first text layer
    if (textLayers.length === 1) {
        showToast('üí° Double-click text to edit, Drag to move, Right-click for options', 'info');
    }
}

function renderTextLayer(layer, autoEdit = false) {
    const container = document.getElementById('textLayersContainer');
    
    // Remove old layer element if exists
    const oldElement = document.getElementById(layer.id);
    if (oldElement) oldElement.remove();
    
    const layerDiv = document.createElement('div');
    layerDiv.id = layer.id;
    layerDiv.className = 'text-layer-wrapper';
    layerDiv.style.cssText = `
        position: absolute;
        left: ${layer.x}%;
        top: ${layer.y}%;
        transform: translate(-50%, -50%);
        cursor: move;
        pointer-events: auto;
        z-index: 10;
        max-width: 80%;
        user-select: none;
    `;
    
    // Create text content
    const textContent = document.createElement('div');
    textContent.className = 'text-layer-content';
    textContent.style.cssText = `
        font-size: ${layer.fontSize}px;
        font-weight: bold;
        font-family: ${layer.fontFamily || 'Arial'}, sans-serif;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        padding: 8px 12px;
        border: 2px solid transparent;
        transition: border 0.2s;
        pointer-events: auto;
        cursor: move;
        border-radius: 4px;
    `;
    
    if (layer.rainbow) {
        const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
        let html = '';
        for (let i = 0; i < layer.text.length; i++) {
            const color = colors[i % colors.length];
            html += `<span style="color: ${color};">${layer.text[i] === '\n' ? '<br>' : layer.text[i]}</span>`;
        }
        textContent.innerHTML = html;
    } else {
        textContent.style.color = layer.color;
        textContent.innerHTML = layer.text.replace(/\n/g, '<br>');
    }
    
    layerDiv.appendChild(textContent);
    
    // Hover effect
    layerDiv.onmouseenter = () => {
        if (textContent.contentEditable !== 'true') { // Only if not editing
            textContent.style.borderColor = 'rgba(13, 202, 240, 0.5)';
            textContent.style.backgroundColor = 'rgba(13, 202, 240, 0.1)';
        }
    };
    layerDiv.onmouseleave = () => {
        if (textContent.contentEditable !== 'true') { // Only if not editing
            textContent.style.borderColor = 'transparent';
            textContent.style.backgroundColor = 'transparent';
        }
    };
    
    // Double-click on wrapper or content to edit inline
    const enableEdit = (e) => {
        e.stopPropagation();
        e.preventDefault();
        console.log('Double-click detected on text layer:', layer.id);
        editTextLayerInline(layer.id);
    };
    
    layerDiv.ondblclick = enableEdit;
    textContent.ondblclick = enableEdit;
    
    // Right-click context menu for options
    layerDiv.oncontextmenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
        showTextContextMenu(e, layer.id);
    };
    
    // Drag functionality - MUST be on the wrapper
    makeDraggableText(layerDiv, layer);
    
    container.appendChild(layerDiv);
    
    // Auto-edit removed - user must double-click to edit
}

function editTextLayerInline(layerId) {
    console.log('editTextLayerInline called for:', layerId);
    
    const layer = textLayers.find(l => l.id === layerId);
    if (!layer) {
        console.error('Layer not found:', layerId);
        return;
    }
    
    const layerElement = document.getElementById(layerId);
    if (!layerElement) {
        console.error('Layer element not found:', layerId);
        return;
    }
    
    const textContent = layerElement.querySelector('.text-layer-content');
    if (!textContent) {
        console.error('Text content not found for:', layerId);
        return;
    }
    
    // Check if already editing
    if (textContent.contentEditable === 'true') {
        console.log('Already editing');
        textContent.focus();
        return;
    }
    
    console.log('Enabling contentEditable for direct editing');
    
    // LOCK image dragging while editing text
    lockImageDragging(true);
    
    // Make text content editable directly
    textContent.contentEditable = 'true';
    textContent.style.outline = '3px solid #0dcaf0';
    textContent.style.outlineOffset = '2px';
    textContent.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    textContent.style.cursor = 'text';
    textContent.style.zIndex = '1000'; // Bring to front
    
    // Store original HTML
    const originalHTML = textContent.innerHTML;
    
    // Clear rainbow formatting for editing (use plain text)
    if (layer.rainbow) {
        textContent.textContent = layer.text;
        textContent.style.color = '#ffffff';
    }
    
    // Focus and select text
    textContent.focus();
    
    // Select all text
    setTimeout(() => {
        const range = document.createRange();
        range.selectNodeContents(textContent);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
    }, 10);
    
    // Function to save and exit edit mode
    const saveAndExit = () => {
        const newText = textContent.textContent.trim();
        layer.text = newText || 'Double click to edit';
        
        // Exit edit mode
        textContent.contentEditable = 'false';
        textContent.style.outline = 'none';
        textContent.style.backgroundColor = 'transparent';
        textContent.style.cursor = 'move';
        textContent.style.zIndex = '10'; // Reset z-index
        
        // UNLOCK image dragging
        lockImageDragging(false);
        
        // Re-render to apply rainbow if needed
        renderTextLayer(layer);
        showToast('Text updated ‚úì', 'success');
    };
    
    // Save on blur (click outside)
    textContent.onblur = saveAndExit;
    
    // Save on Escape key
    textContent.onkeydown = (e) => {
        if (e.key === 'Escape') {
            e.preventDefault();
            textContent.blur();
        }
        e.stopPropagation();
    };
    
    // Prevent double-click while editing
    textContent.ondblclick = (e) => {
        e.stopPropagation();
    };
}

function showColorPicker(layerId) {
    const layer = textLayers.find(l => l.id === layerId);
    if (!layer) return;
    
    currentEditingLayer = layer;
    
    // Position toolbar near the text layer
    const layerElement = document.getElementById(layerId);
    const rect = layerElement.getBoundingClientRect();
    
    const toolbar = document.getElementById('textColorToolbar');
    toolbar.style.display = 'block';
    toolbar.style.left = Math.min(rect.left, window.innerWidth - 300) + 'px';
    toolbar.style.top = (rect.bottom + 10) + 'px';
    
    // Set current values
    document.getElementById('toolbarColorPicker').value = layer.color;
    document.getElementById('toolbarColorCode').value = layer.color;
    document.getElementById('toolbarRainbowMode').checked = layer.rainbow;
}

// OLD FUNCTIONS - KEPT FOR COMPATIBILITY (can be removed later)
function deleteTextLayer(layerId) {
    textLayers = textLayers.filter(l => l.id !== layerId);
    const element = document.getElementById(layerId);
    if (element) element.remove();
    showToast('Text layer deleted', 'success');
}

function showTextContextMenu(event, layerId) {
    event.preventDefault();
    event.stopPropagation();
    
    const layer = textLayers.find(l => l.id === layerId);
    if (!layer) return;
    
    currentEditingLayer = layer;
    
    // Close any open menus first
    closeAllMenus();
    
    // Show main context menu
    const contextMenu = document.getElementById('textContextMenu');
    contextMenu.style.display = 'block';
    contextMenu.style.left = event.clientX + 'px';
    contextMenu.style.top = event.clientY + 'px';
    
    // Setup submenu hover events
    setupSubmenuHovers(event.clientX, event.clientY);
    
    // Close menu on click outside
    setTimeout(() => {
        document.addEventListener('click', closeAllMenus);
    }, 100);
}

function setupSubmenuHovers(menuX, menuY) {
    const colorMenuItem = document.getElementById('colorMenuItem');
    const fontMenuItem = document.getElementById('fontMenuItem');
    const colorSubmenu = document.getElementById('colorSubmenu');
    const fontSubmenu = document.getElementById('fontSubmenu');
    const contextMenu = document.getElementById('textContextMenu');
    
    // Color submenu hover
    colorMenuItem.onmouseenter = () => {
        fontSubmenu.style.display = 'none';
        colorSubmenu.style.display = 'block';
        
        const rect = colorMenuItem.getBoundingClientRect();
        colorSubmenu.style.left = (rect.right + 5) + 'px';
        colorSubmenu.style.top = rect.top + 'px';
        
        // Populate preset colors
        populatePresetColors();
        
        // Set current values
        document.getElementById('colorCodeInput').value = currentEditingLayer.color;
        document.getElementById('rainbowCheckbox').checked = currentEditingLayer.rainbow;
    };
    
    // Font submenu hover
    fontMenuItem.onmouseenter = () => {
        colorSubmenu.style.display = 'none';
        fontSubmenu.style.display = 'block';
        
        const rect = fontMenuItem.getBoundingClientRect();
        fontSubmenu.style.left = (rect.right + 5) + 'px';
        fontSubmenu.style.top = rect.top + 'px';
        
        // Populate font list
        populateFontList();
    };
    
    // Keep submenus open when hovering over them
    colorSubmenu.onmouseenter = () => {
        colorSubmenu.style.display = 'block';
    };
    
    fontSubmenu.onmouseenter = () => {
        fontSubmenu.style.display = 'block';
    };
}

function populatePresetColors() {
    const presetColors = [
        '#FFFFFF', '#000000', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
        '#FFA500', '#800080', '#FFC0CB', '#A52A2A', '#808080', '#00FF7F', '#4B0082', '#FFD700',
        '#FF69B4', '#32CD32', '#1E90FF', '#FF4500', '#8A2BE2', '#20B2AA', '#DC143C', '#7FFF00'
    ];
    
    const container = document.getElementById('presetColors');
    container.innerHTML = '';
    
    presetColors.forEach(color => {
        const div = document.createElement('div');
        div.className = 'color-preset';
        div.style.backgroundColor = color;
        div.title = color;
        div.onclick = () => applyColor(color);
        container.appendChild(div);
    });
}

function populateFontList() {
    const fonts = [
        'Arial',
        'Helvetica',
        'Impact',
        'Comic Sans MS',
        'Courier New',
        'Georgia',
        'Palatino',
        'Garamond',
        'Bookman',
        'Trebuchet MS',
        'Arial Black',
        'Verdana',
        'Times New Roman',
        'Brush Script MT',
        'Lucida Handwriting',
        'Copperplate',
        'Papyrus',
        'Lobster',
        'Pacifico',
        'Oswald',
        'Montserrat',
        'Playfair Display',
        'Bebas Neue',
        'Anton'
    ];
    
    const container = document.getElementById('fontList');
    container.innerHTML = '';
    
    fonts.forEach(font => {
        const div = document.createElement('div');
        div.className = 'font-item';
        div.textContent = font;
        div.style.fontFamily = font;
        div.onclick = () => applyFont(font);
        container.appendChild(div);
    });
}

function applyColor(color) {
    if (!currentEditingLayer) return;
    
    currentEditingLayer.color = color;
    currentEditingLayer.rainbow = false;
    renderTextLayer(currentEditingLayer);
    showToast('Color applied ‚úì', 'success');
    closeAllMenus();
}

function applyCustomColor() {
    const input = document.getElementById('colorCodeInput');
    let color = input.value.trim();
    
    // Add # if missing
    if (!color.startsWith('#')) {
        color = '#' + color;
    }
    
    // Validate hex color
    if (!/^#[0-9A-F]{6}$/i.test(color)) {
        showToast('Invalid color code! Use format: #FFFFFF', 'warning');
        return;
    }
    
    applyColor(color);
}

function applyRainbowMode(enabled) {
    if (!currentEditingLayer) return;
    
    currentEditingLayer.rainbow = enabled;
    
    if (!enabled) {
        // Use current color when disabling rainbow
        currentEditingLayer.color = document.getElementById('colorCodeInput').value || '#FFFFFF';
    }
    
    renderTextLayer(currentEditingLayer);
    showToast(enabled ? 'Rainbow mode enabled üåà' : 'Rainbow mode disabled', 'success');
}

function applyFont(font) {
    if (!currentEditingLayer) return;
    
    currentEditingLayer.fontFamily = font;
    renderTextLayer(currentEditingLayer);
    showToast(`Font changed to ${font} ‚úì`, 'success');
    closeAllMenus();
}

function deleteCurrentTextLayer() {
    if (!currentEditingLayer) return;
    
    textLayers = textLayers.filter(l => l.id !== currentEditingLayer.id);
    const element = document.getElementById(currentEditingLayer.id);
    if (element) element.remove();
    
    showToast('Text layer deleted', 'success');
    closeAllMenus();
    currentEditingLayer = null;
}

function closeAllMenus() {
    document.getElementById('textContextMenu').style.display = 'none';
    document.getElementById('colorSubmenu').style.display = 'none';
    document.getElementById('fontSubmenu').style.display = 'none';
    document.removeEventListener('click', closeAllMenus);
}

function makeDraggableText(element, layer) {
    let isDragging = false;
    let startX, startY;
    let dragStartTime = 0;
    
    element.onpointerdown = (e) => {
        // Check if text is being edited
        const textContent = element.querySelector('.text-layer-content');
        if (textContent && textContent.contentEditable === 'true') {
            return; // Don't drag while editing
        }
        
        // Don't start drag on double-click
        if (e.detail === 2) {
            return;
        }
        
        isDragging = true;
        dragStartTime = Date.now();
        startX = e.clientX;
        startY = e.clientY;
        element.style.cursor = 'grabbing';
        
        // Add visual feedback
        if (textContent) {
            textContent.style.borderColor = 'rgba(13, 202, 240, 0.8)';
            textContent.style.borderWidth = '3px';
        }
        
        e.preventDefault();
        e.stopPropagation();
    };
    
    document.onpointermove = (e) => {
        if (!isDragging) return;
        
        const container = document.getElementById('textLayersContainer');
        const rect = container.getBoundingClientRect();
        
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        layer.x += (deltaX / rect.width) * 100;
        layer.y += (deltaY / rect.height) * 100;
        
        // Clamp values
        layer.x = Math.max(5, Math.min(95, layer.x));
        layer.y = Math.max(5, Math.min(95, layer.y));
        
        element.style.left = layer.x + '%';
        element.style.top = layer.y + '%';
        
        startX = e.clientX;
        startY = e.clientY;
    };
    
    document.onpointerup = (e) => {
        if (isDragging) {
            element.style.cursor = 'move';
            isDragging = false;
            
            // Reset border after drag
            const textContent = element.querySelector('.text-layer-content');
            if (textContent) {
                textContent.style.borderWidth = '2px';
            }
        }
    };
}

// Collage Settings Dropdown Toggle
document.addEventListener('DOMContentLoaded', () => {
    // Setup drag & drop and paste
    setupDragDropPaste();
    
    // Disable right-click context menu on photo display areas
    const photoAreas = [
        document.getElementById('singleImageViewer'),
        document.getElementById('collage-tiles'),
        document.getElementById('collageCanvasContainer'),
        document.getElementById('uploadedPhotosPreview')
    ];
    
    photoAreas.forEach(area => {
        if (area) {
            area.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
        }
    });
    
    const settingsBtn = document.getElementById('collageSettingsBtn');
    const settingsMenu = document.getElementById('collageSettingsMenu');
    
    if (settingsBtn && settingsMenu) {
        // Toggle on hover
        settingsBtn.addEventListener('mouseenter', () => {
            settingsMenu.style.display = 'block';
        });
        
        // Keep menu open when hovering over it
        settingsMenu.addEventListener('mouseenter', () => {
            settingsMenu.style.display = 'block';
        });
        
        // Close when mouse leaves both button and menu
        settingsBtn.addEventListener('mouseleave', (e) => {
            setTimeout(() => {
                if (!settingsMenu.matches(':hover') && !settingsBtn.matches(':hover')) {
                    settingsMenu.style.display = 'none';
                }
            }, 100);
        });
        
        settingsMenu.addEventListener('mouseleave', () => {
            setTimeout(() => {
                if (!settingsBtn.matches(':hover')) {
                    settingsMenu.style.display = 'none';
                }
            }, 100);
        });
    }
    
    const toolbarColorPicker = document.getElementById('toolbarColorPicker');
    const toolbarColorCode = document.getElementById('toolbarColorCode');
    
    if (toolbarColorPicker && toolbarColorCode) {
        toolbarColorPicker.addEventListener('input', (e) => {
            toolbarColorCode.value = e.target.value;
        });
        
        toolbarColorCode.addEventListener('input', (e) => {
            if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
                toolbarColorPicker.value = e.target.value;
            }
        });
    }
    
    // Restore cached images from localStorage
    restoreCachedImages();
    
    // Load history from localStorage
    loadCollageHistoryFromStorage();
});

function restoreCachedImages() {
    // Restore Collage images only (Edit Image removed)
    const cachedCollageData = localStorage.getItem(STORAGE_KEY_COLLAGE_IMAGES);
    if (cachedCollageData) {
        try {
            const imageDataArray = JSON.parse(cachedCollageData);
            collageImages = [];
            let loadedCount = 0;
            
            imageDataArray.forEach((dataURL, index) => {
                const img = new Image();
                img.onload = function() {
                    collageImages[index] = img;
                    loadedCount++;
                    
                    if (loadedCount === imageDataArray.length) {
                        // All images loaded, update UI
                        document.getElementById('collagePrompt').style.display = 'none';
                        
                        // Check if single image - show single viewer
                        if (imageDataArray.length === 1) {
                            showSingleImageViewer(collageImages[0]);
                            console.log('Restored 1 image in single viewer mode');
                            return;
                        }
                        
                        // Multiple images - show collage mode
                        document.getElementById('uploadedPhotosPreview').style.display = 'flex';
                        
                        // Hide canvas/tiles if they were showing
                        document.getElementById('collageCanvasContainer').style.display = 'none';
                        const tiles = document.getElementById('collage-tiles');
                        if (tiles) tiles.style.display = 'none';
                        
                        // Recreate preview thumbnails with proper structure
                        const previewContainer = document.getElementById('uploadedPhotosPreview');
                        previewContainer.innerHTML = '';
                        collageImages.forEach((img, i) => {
                            const col = document.createElement('div');
                            col.className = 'col-auto';
                            col.innerHTML = `
                                <div class="position-relative" style="width: 80px; height: 80px;">
                                    <img src="${img.src}" 
                                         class="img-thumbnail" 
                                         style="width: 100%; height: 100%; object-fit: cover;">
                                </div>
                            `;
                            previewContainer.appendChild(col);
                        });
                        
                        // Re-render layout templates
                        renderLayoutTemplates();
                        
                        // Auto-select matching layout
                        const matchingLayout = layoutTemplates.find(l => l.maxPhotos === collageImages.length);
                        if (matchingLayout) {
                            selectLayout(matchingLayout.id);
                        }
                        
                        console.log(`Restored ${collageImages.length} collage images from cache`);
                    }
                };
                img.src = dataURL;
            });
        } catch (e) {
            console.error('Failed to restore collage images:', e);
        }
    }
}

function clearCollage() {
    collageImages = [];
    imageOffsets = [];
    imagePositions = []; // Reset saved positions
    selectedLayout = null;
    
    // Clear text layers
    textLayers = [];
    document.getElementById('textLayersContainer').innerHTML = '';
    
    // Hide single image viewer
    const singleViewer = document.getElementById('singleImageViewer');
    singleViewer.style.display = 'none';
    
    // Clear canvas if exists
    if (singleImageCanvas) {
        singleImageCtx.clearRect(0, 0, singleImageCanvas.width, singleImageCanvas.height);
        singleImageCanvas.style.transform = 'scale(1)';
        if (zoomListener) {
            singleImageCanvas.removeEventListener('wheel', zoomListener);
        }
    }
    
    document.getElementById('collageCanvasContainer').style.display = 'none';
    document.getElementById('collage-tiles').style.display = 'none';
    document.getElementById('collagePrompt').style.display = 'block';
    document.getElementById('uploadedPhotosPreview').style.display = 'none';
    document.getElementById('uploadedPhotosPreview').innerHTML = '';
    document.getElementById('collageUpload').value = '';
    
    // Clear cache
    clearImageCache('collage');
    
    renderLayoutTemplates();
    showToast('Collage cleared', 'info');
}

async function saveCollage() {
    const tilesContainer = document.getElementById('collage-tiles');
    
    if (tilesContainer.style.display === 'none' || collageImages.length === 0) {
        showToast('Please create a collage first', 'warning');
        return;
    }
    
    try {
        // Get settings
        const gutter = parseInt(document.getElementById('collageGutter').value);
        const radius = parseInt(document.getElementById('collageRadius').value);
        const borderWidth = parseInt(document.getElementById('collageBorder').value);
        const borderColor = document.getElementById('collageBorderColor').value;
        const backgroundColor = document.getElementById('collageBackground').value;
        const layout = layoutTemplates.find(l => l.id === selectedLayout);
        
        // Create high-res canvas (1080x1080)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1080;
        canvas.height = 1080;
        
        // Fill background
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(0, 0, 1080, 1080);
        
        // Set high quality rendering
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        // Calculate grid
        const padding = gutter * 1.5; // Scale gutter for 1080
        const availableW = 1080 - padding * 2;
        const availableH = 1080 - padding * 2;
        const cellW = availableW / layout.cols;
        const cellH = availableH / layout.rows;
        const gap = gutter * 1.5;
        
        // Draw each image
        for (let i = 0; i < Math.min(collageImages.length, layout.cells.length); i++) {
            const [col, row, colSpan, rowSpan] = layout.cells[i];
            const img = collageImages[i];
            const pos = imagePositions[i] || { x: 50, y: 50 };
            
            // Calculate position and size
            const x = padding + col * cellW + (col > 0 ? gap * col : 0);
            const y = padding + row * cellH + (row > 0 ? gap * row : 0);
            const w = cellW * colSpan - (colSpan > 1 ? gap : 0);
            const h = cellH * rowSpan - (rowSpan > 1 ? gap : 0);
            
            // Save context
            ctx.save();
            
            // Clip with rounded corners
            if (radius > 0) {
                const r = radius * 1.5;
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.arcTo(x + w, y, x + w, y + r, r);
                ctx.lineTo(x + w, y + h - r);
                ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
                ctx.lineTo(x + r, y + h);
                ctx.arcTo(x, y + h, x, y + h - r, r);
                ctx.lineTo(x, y + r);
                ctx.arcTo(x, y, x + r, y, r);
                ctx.closePath();
                ctx.clip();
            }
            
            // Draw image with object-fit: cover logic
            const imgAspect = img.width / img.height;
            const targetAspect = w / h;
            let drawW, drawH, drawX, drawY;
            
            if (imgAspect > targetAspect) {
                // Image wider than target
                drawH = h;
                drawW = img.width * (h / img.height);
                drawX = x - (drawW - w) * (pos.x / 100);
                drawY = y;
            } else {
                // Image taller than target
                drawW = w;
                drawH = img.height * (w / img.width);
                drawX = x;
                drawY = y - (drawH - h) * (pos.y / 100);
            }
            
            ctx.drawImage(img, drawX, drawY, drawW, drawH);
            ctx.restore();
            
            // Draw border
            if (borderWidth > 0) {
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = borderWidth * 1.5;
                
                if (radius > 0) {
                    const r = radius * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.arcTo(x + w, y, x + w, y + r, r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
                    ctx.lineTo(x + r, y + h);
                    ctx.arcTo(x, y + h, x, y + h - r, r);
                    ctx.lineTo(x, y + r);
                    ctx.arcTo(x, y, x + r, y, r);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    ctx.strokeRect(x, y, w, h);
                }
            }
        }
        
        // Draw text layers
        for (const layer of textLayers) {
            const x = (layer.x / 100) * 1080;
            const y = (layer.y / 100) * 1080;
            
            ctx.font = `bold ${layer.fontSize * 1.5}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Text shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 6;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            if (layer.rainbow) {
                // Rainbow text
                const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
                let offsetX = -ctx.measureText(layer.text).width / 2;
                
                for (let i = 0; i < layer.text.length; i++) {
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fillText(layer.text[i], x + offsetX, y);
                    offsetX += ctx.measureText(layer.text[i]).width;
                }
            } else {
                ctx.fillStyle = layer.color;
                ctx.fillText(layer.text, x, y);
            }
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Convert to blob
        canvas.toBlob(async (blob) => {
            // 1. Download to user's computer
            const link = document.createElement('a');
            link.download = `collage-${Date.now()}.png`;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
            
            // 2. Save thumbnail to server
            const formData = new FormData();
            formData.append('image', blob, 'collage.png');
            formData.append('imageCount', collageImages.length);
            formData.append('layout', selectedLayout);
            
            // Include thumbnails of original images
            for (let i = 0; i < collageImages.length; i++) {
                formData.append('thumbnails', collageImages[i].src);
            }
            
            const response = await fetch('/image/api/save-collage', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const data = await response.json();
                // History is now managed via localStorage, no need to reload
                showToast('Collage saved successfully!', 'success');
            } else {
                showToast('Collage downloaded, but failed to save to history', 'warning');
            }
        }, 'image/png', 1.0);
        
    } catch (error) {
        console.error('Save error:', error);
        showToast('Failed to save collage: ' + error.message, 'danger');
    }
}

// OLD SERVER-BASED HISTORY FUNCTIONS (DEPRECATED - Now using localStorage)
/*
// View history collage - Display in main preview
async function viewHistoryCollage(collageId) {
    try {
        const url = `/image/api/collage-thumbnail/${collageId}`;
        
        // Create temporary image element to load the collage
        const img = new Image();
        img.onload = function() {
            // Clear current collage
            collageImages = [];
            imageOffsets = [];
            imagePositions = [];
            textLayers = [];
            document.getElementById('textLayersContainer').innerHTML = '';
            selectedLayout = null;
            
            // Hide collage tiles, show canvas container instead
            document.getElementById('collage-tiles').style.display = 'none';
            document.getElementById('collagePrompt').style.display = 'none';
            
            // Display the saved collage image directly
            const canvasContainer = document.getElementById('collageCanvasContainer');
            canvasContainer.style.display = 'block';
            canvasContainer.innerHTML = 
                '<div style="width: 100%; height: 720px; display: flex; align-items: center; justify-content: center; background: #000;">' +
                    '<img src="' + url + '" style="max-width: 100%; max-height: 100%; object-fit: contain;" alt="Saved Collage">' +
                '</div>';
            
            showToast('History collage loaded (view only)', 'info');
        };
        
        img.onerror = function() {
            showToast('Failed to load collage from history', 'danger');
        };
        
        img.src = url;
        
    } catch (error) {
        console.error('Failed to view history:', error);
        showToast('Error loading collage', 'danger');
    }
}

// Load collage history from server
async function loadCollageHistory() {
    try {
        const response = await fetch('/image/api/collage-history');
        const data = await response.json();
        
        const container = document.getElementById('collageHistory');
        
        if (!data.history || data.history.length === 0) {
            container.innerHTML = '<small class="text-muted text-center py-3">No saved collages</small>';
            return;
        }
        
        container.innerHTML = data.history.map(item => `
            <div class="history-item" 
                 data-id="${item.id}"
                 title="${item.date} - ${item.imageCount} photos"
                 onclick="viewHistoryCollage('${item.id}')"
                 oncontextmenu="showContextMenu(event, '${item.id}'); return false;">
                <img src="/image/api/collage-thumbnail/${item.id}" alt="Collage">
                <div class="history-item-date">${item.imageCount} photos</div>
            </div>
        `).join('');
        
    } catch (error) {
        console.error('Failed to load history:', error);
    }
}

// Show context menu
function showContextMenu(event, id) {
    event.preventDefault();
    
    // Remove existing context menu
    const existing = document.querySelector('.context-menu');
    if (existing) existing.remove();
    
    // Create context menu
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.style.left = event.pageX + 'px';
    menu.style.top = event.pageY + 'px';
    menu.innerHTML = `
        <div class="context-menu-item" onclick="deleteCollageFromHistory('${id}')">
            <i class="bi bi-trash"></i>Delete
        </div>
    `;
    
    document.body.appendChild(menu);
    
    // Close on click outside
    const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
        }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 100);
}

// Delete collage from history
async function deleteCollageFromHistory(id) {
    try {
        const response = await fetch(`/image/api/collage-delete/${id}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            loadCollageHistory(); // Reload history
            showToast('Collage deleted', 'info');
        } else {
            showToast('Failed to delete collage', 'danger');
        }
    } catch (error) {
        console.error('Failed to delete:', error);
        showToast('Failed to delete collage', 'danger');
    }
}
*/

// Initialize layout templates on page load
document.addEventListener('DOMContentLoaded', function() {
    renderLayoutTemplates();
    // History is now loaded via loadCollageHistoryFromStorage() in earlier DOMContentLoaded handler
    
    // Apply UI if collage is already loaded
    if (typeof applyUI === 'function') {
        applyUI();
    }
    
    // Bind locked drag to all images in collage-tiles
    document.querySelectorAll('#collage-tiles .tile > img').forEach(bindLockedDrag);
    
    // Keyboard shortcuts for collage
    document.addEventListener('keydown', function(e) {
        // Only work in collage tab
        const collageTab = document.getElementById('collage-panel');
        if (!collageTab || !collageTab.classList.contains('active')) return;
        
        // [ key - decrease gutter
        if (e.key === '[') {
            const gutterSlider = document.getElementById('collageGutter');
            const currentValue = parseInt(gutterSlider.value);
            if (currentValue > parseInt(gutterSlider.min)) {
                gutterSlider.value = currentValue - 1;
                document.getElementById('gutterValue2').textContent = gutterSlider.value;
                if (selectedLayout && collageImages.length > 0) {
                    createCollageWithLayout();
                }
            }
            e.preventDefault();
        }
        
        // ] key - increase gutter
        if (e.key === ']') {
            const gutterSlider = document.getElementById('collageGutter');
            const currentValue = parseInt(gutterSlider.value);
            if (currentValue < parseInt(gutterSlider.max)) {
                gutterSlider.value = currentValue + 1;
                document.getElementById('gutterValue2').textContent = gutterSlider.value;
                if (selectedLayout && collageImages.length > 0) {
                    createCollageWithLayout();
                }
            }
            e.preventDefault();
        }
        
        // T key - add text layer
        if (e.key === 't' || e.key === 'T') {
            toggleTextLayer();
            e.preventDefault();
        }
    });
});
</script>
{% endraw %}

<style>
/* Text Editor Panel Styles */
#textEditorPanel {
    animation: slideIn 0.2s ease-out;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translate(-50%, -45%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

.text-layer {
    transition: transform 0.1s ease;
}

.text-layer:hover {
    transform: scale(1.05);
}

/* Layout Template Styles */
.layout-template {
    cursor: pointer;
    padding: 12px;
    border: 2px solid #495057;
    border-radius: 8px;
    transition: all 0.3s ease;
    background: #2c3034;
    min-width: 100px;
    min-height: 110px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.layout-template:hover:not(.disabled) {
    border-color: #0dcaf0;
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(13, 202, 240, 0.2);
}

.layout-template.selected {
    border-color: #0dcaf0;
    background: #1a4d5a;
    box-shadow: 0 0 15px rgba(13, 202, 240, 0.4);
}

.layout-template.disabled {
    opacity: 0.3;
    cursor: not-allowed;
    background: #1a1a1a;
}

#uploadedPhotosPreview {
    max-height: 450px;
    overflow-y: auto;
    padding: 10px;
}

#layoutTemplates {
    display: flex;
    gap: 10px;
    overflow-x: auto;
    padding-bottom: 10px;
}

#layoutTemplates::-webkit-scrollbar {
    height: 8px;
}

#layoutTemplates::-webkit-scrollbar-track {
    background: #1a1a1a;
    border-radius: 4px;
}

#layoutTemplates::-webkit-scrollbar-thumb {
    background: #495057;
    border-radius: 4px;
}

#layoutTemplates::-webkit-scrollbar-thumb:hover {
    background: #6c757d;
}

/* Vertical divider */
.vr {
    background-color: #495057;
    opacity: 0.5;
    width: 1px;
}
</style>
{% endblock %}
