{% extends "layouts/base.html" %}

{% block content %}
<div class="container-fluid" style="padding: 0.5rem 1rem;">
    <!-- Action Buttons and Groups - All in one row -->
    <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
        <!-- WeChat Groups on the left -->
        <div class="d-flex gap-2 align-items-center flex-wrap" id="mxh-groups-nav">
            <!-- Groups will be rendered here by JavaScript -->
        </div>

        <!-- Action buttons on the right -->
        <div class="d-flex gap-2 align-items-center flex-wrap">
            <button class="btn btn-sm btn-info" data-bs-toggle="modal" data-bs-target="#mxh-view-mode-modal">
                <i class="bi bi-grid-3x3-gap me-1"></i> Ch·∫ø ƒê·ªô Xem
            </button>
            <button class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#mxh-addAccountModal">
                <i class="bi bi-plus-lg me-1"></i> Th√™m T√†i Kho·∫£n
            </button>
        </div>
    </div>

    <div id="mxh-accounts-container">
        <!-- MXH accounts will be rendered here -->
        <div class="card">
            <div class="card-body text-center text-muted">
                <i class="bi bi-share-fill" style="font-size: 3rem; opacity: 0.3;"></i>
                <h5 class="mt-3">ƒêang t·∫£i...</h5>
            </div>
        </div>
    </div>
</div>

<!-- MXH View Mode Modal -->
<div class="modal fade" id="mxh-view-mode-modal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header" style="height: 44px; padding: 0.5rem 1rem;">
                <h5 class="modal-title"><i class="bi bi-grid-3x3-gap me-2"></i>Ch·∫ø ƒê·ªô Xem</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="mxh-cards-per-row" class="form-label">S·ªë Cards M·ªói H√†ng</label>
                    <input type="number" class="form-control" id="mxh-cards-per-row"
                        placeholder="Nh·∫≠p s·ªë cards m·ªói h√†ng..." min="1" max="20" value="12">
                    <div class="form-text">Nh·∫≠p s·ªë t·ª´ 1 ƒë·∫øn 20. V√≠ d·ª•: 12 = 12 cards m·ªói h√†ng</div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">H·ªßy</button>
                <button type="button" class="btn btn-primary" id="mxh-apply-view-mode-btn">√Åp D·ª•ng</button>
            </div>
        </div>
    </div>
</div>

<!-- MXH Add Account Modal -->
<div class="modal fade" id="mxh-addAccountModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-plus-lg me-2"></i>Th√™m T√†i Kho·∫£n MXH</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row mb-2">
                    <div class="col-md-6">
                        <label for="mxh-username" class="form-label mb-1">T√™n Ng∆∞·ªùi D√πng</label>
                        <input type="text" class="form-control form-control-sm" id="mxh-username"
                            placeholder="Nh·∫≠p t√™n ng∆∞·ªùi d√πng...">
                    </div>
                    <div class="col-md-6">
                        <label for="mxh-platform" class="form-label mb-1">N·ªÅn T·∫£ng</label>
                        <select class="form-select form-select-sm" id="mxh-platform" required>
                            <option value="">Ch·ªçn n·ªÅn t·∫£ng...</option>
                            <option value="facebook">Facebook</option>
                            <option value="instagram">Instagram</option>
                            <option value="twitter">Twitter</option>
                            <option value="zalo">Zalo</option>
                            <option value="wechat">WeChat</option>
                            <option value="telegram">Telegram</option>
                            <option value="whatsapp">WhatsApp</option>
                        </select>
                    </div>
                </div>
                <div class="row mb-2">
                    <div class="col-md-6">
                        <label for="mxh-password" class="form-label mb-1">M·∫≠t Kh·∫©u</label>
                        <input type="text" class="form-control form-control-sm" id="mxh-password"
                            placeholder="Nh·∫≠p m·∫≠t kh·∫©u...">
                    </div>
                    <div class="col-md-6">
                        <label for="mxh-phone" class="form-label mb-1">S·ªë ƒêi·ªán Tho·∫°i</label>
                        <input type="text" class="form-control form-control-sm" id="mxh-phone"
                            placeholder="Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i...">
                    </div>
                </div>
                <div class="row mb-2">
                    <div class="col-md-6">
                        <label for="mxh-url" class="form-label mb-1">URL (t√πy ch·ªçn)</label>
                        <input type="url" class="form-control form-control-sm" id="mxh-url" placeholder="https://...">
                    </div>
                    <div class="col-md-6">
                        <label class="form-label mb-1">Ng√†y T·∫°o</label>
                        <div class="row g-0">
                            <div class="col-auto"><input type="number" class="form-control form-control-sm w-auto"
                                    id="mxh-day" placeholder="Ng√†y" min="1" max="31" maxlength="2" style="width:56px"
                                    required></div>
                            <div class="col-auto"><input type="number" class="form-control form-control-sm w-auto"
                                    id="mxh-month" placeholder="Th√°ng" min="1" max="12" maxlength="2" style="width:56px"
                                    required>
                            </div>
                            <div class="col-auto"><input type="number" class="form-control form-control-sm w-auto"
                                    id="mxh-year" placeholder="NƒÉm" min="2020" max="2030" maxlength="4"
                                    style="width:76px" required>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">H·ªßy</button>
                <button type="button" class="btn btn-primary btn-sm" id="mxh-save-account-btn">T·∫°o Card</button>
            </div>
        </div>
    </div>
</div>
<!-- MXH Background Context Menu -->
<div id="mxh-background-context-menu" class="custom-context-menu" style="display: none;">
    <div class="menu-item" data-action="view-mode">
        <i class="bi bi-grid-3x3-gap me-2"></i> Ch·∫ø ƒê·ªô Xem
    </div>
    <div class="menu-item" data-action="add-account">
        <i class="bi bi-plus-lg me-2"></i> + Th√™m T√†i Kho·∫£n MXH
    </div>
</div>

<!-- WeChat Account Modal -->
<div class="modal fade" id="wechat-account-modal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered" style="max-width: 400px;">
        <div class="modal-content">
            <div class="modal-header" style="height: 50px; padding: 8px 16px;">
                <h10 class="modal-title" style="font-size: 1rem; margin: 0;"><i class="bi bi-wechat me-2"></i>Th√¥ng Tin
                    T√†i Kho·∫£n WeChat</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" style="font-size: 0.8rem;"></button>
            </div>
            <div class="modal-body">
                <div class="row mb-2">
                    <div style="width: 80px; display: inline-block; margin-right: 1px;">
                        <label class="form-label mb-1">Card</label>
                        <input type="text" class="form-control form-control-sm" id="wechat-card-name" maxlength="3"
                            required style="width: 100%;">
                    </div>
                    <div style="width: 140px; display: inline-block;">
                        <label class="form-label mb-1">Ng√†y T·∫°o</label>
                        <input type="text" class="form-control form-control-sm" id="wechat-date"
                            placeholder="dd/mm/yyyy" maxlength="10" required style="width: 80%;">
                    </div>
                    <div style="width: 160px; display: inline-block;">
                        <label class="form-label mb-10">Tr·∫°ng Th√°i</label>
                        <select class="form-select form-select-sm" id="wechat-status" required style="width: 100%;">
                            <option value="active">Available</option>
                            <option value="disabled">V√¥ hi·ªáu h√≥a</option>
                            <option value="die">Die</option>
                        </select>
                    </div>
                </div>
                <div class="row" style="margin-bottom: 1px;">
                    <div style="width: 200px; display: inline-block; margin-right: 1px;">
                        <label class="form-label mb-1" style="margin-bottom: 1ch;">T√™n Ng∆∞·ªùi D√πng</label>
                        <input type="text" class="form-control form-control-sm" id="wechat-username" required
                            style="width: 100%;">
                    </div>
                    <div style="width: 180px; display: inline-block;">
                        <label class="form-label mb-1" style="margin-bottom: 1px;">S·ªë ƒêi·ªán Tho·∫°i</label>
                        <input type="text" class="form-control form-control-sm" id="wechat-phone"
                            placeholder="Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i..." maxlength="13" style="width: 100%;">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-danger btn-sm" id="wechat-reset-btn">Reset</button>
                <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary btn-sm" id="wechat-apply-btn">Apply</button>
            </div>
        </div>
    </div>
</div>

<!-- Generic Account Edit Modal -->
<div class="modal fade" id="generic-account-modal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <form id="generic-account-edit-form">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="bi bi-pencil-square me-2"></i>Th√¥ng Tin</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="row mb-2">
                        <div class="col-md-6">
                            <label for="generic-username" class="form-label mb-1">T√™n ƒëƒÉng nh·∫≠p</label>
                            <input type="text" class="form-control form-control-sm" id="generic-username"
                                placeholder="Nh·∫≠p t√™n ƒëƒÉng nh·∫≠p...">
                        </div>
                        <div class="col-md-6">
                            <label for="generic-password" class="form-label mb-1">M·∫≠t kh·∫©u</label>
                            <input type="password" class="form-control form-control-sm" id="generic-password"
                                placeholder="Nh·∫≠p m·∫≠t kh·∫©u...">
                        </div>
                    </div>
                    <div class="mb-2">
                        <label for="generic-display-name" class="form-label mb-1">T√™n ng∆∞·ªùi d√πng</label>
                        <input type="text" class="form-control form-control-sm" id="generic-display-name"
                            placeholder="Nh·∫≠p t√™n ng∆∞·ªùi d√πng...">
                    </div>
                    <div class="mb-2">
                        <label for="generic-phone" class="form-label mb-1">S·ªë ƒëi·ªán tho·∫°i</label>
                        <input type="text" class="form-control form-control-sm" id="generic-phone"
                            placeholder="Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i...">
                    </div>
                    <div class="mb-2">
                        <label for="generic-url" class="form-label mb-1">URL</label>
                        <input type="url" class="form-control form-control-sm" id="generic-url"
                            placeholder="Nh·∫≠p URL...">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger btn-sm" id="generic-reset-btn">Reset</button>
                    <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">H·ªßy</button>
                    <button type="submit" class="btn btn-primary btn-sm" id="generic-apply-btn">√Åp d·ª•ng</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Change Card Number Modal -->
<div class="modal fade" id="change-card-number-modal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-123 me-2"></i>ƒê·ªïi S·ªë Hi·ªáu Card</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="new-card-number" class="form-label">S·ªë hi·ªáu m·ªõi</label>
                    <input type="number" class="form-control" id="new-card-number" placeholder="Nh·∫≠p s·ªë hi·ªáu m·ªõi..."
                        min="1" required>
                    <div class="form-text">Nh·∫≠p s·ªë hi·ªáu m·ªõi cho card n√†y</div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">H·ªßy</button>
                <button type="button" class="btn btn-primary" id="apply-card-number-btn">√Åp D·ª•ng</button>
            </div>
        </div>
    </div>
</div>

<!-- Notice Modal -->
<div class="modal fade" id="noticeModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-bell-fill me-2"></i>ƒê·∫∑t Th√¥ng B√°o</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row g-2 align-items-end mb-3">
                    <div class="col-8">
                        <label for="noticeTitle" class="form-label">Ti√™u ƒê·ªÅ</label>
                        <input type="text" class="form-control" id="noticeTitle" placeholder="Nh·∫≠p ti√™u ƒë·ªÅ..."
                            value="Th√¥ng b√°o">
                    </div>
                    <div class="col-4">
                        <label for="noticeDays" class="form-label">S·ªë ng√†y</label>
                        <input type="number" class="form-control" id="noticeDays" min="1" step="1" value="30">
                    </div>
                </div>
                <div class="mb-3">
                    <textarea class="form-control" id="noticeNote" rows="3" placeholder="Ghi ch√∫..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">H·ªßy</button>
                <button type="button" class="btn btn-primary" onclick="submitNotice()">L∆∞u</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div class="modal fade" id="delete-card-modal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-exclamation-triangle me-2 text-warning"></i>X√°c Nh·∫≠n X√≥a Card
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p>B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a card n√†y kh√¥ng?</p>
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    <strong>L∆∞u √Ω:</strong> H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c. T·∫•t c·∫£ d·ªØ li·ªáu c·ªßa card s·∫Ω b·ªã x√≥a vƒ©nh
                    vi·ªÖn.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">H·ªßy B·ªè</button>
                <button type="button" class="btn btn-danger" id="confirm-delete-btn">X√°c Nh·∫≠n X√≥a</button>
            </div>
        </div>
    </div>
</div>

<!-- Reset Card Confirmation Modal -->
<div class="modal fade" id="reset-card-modal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h10 class="modal-title"><i class="bi bi-arrow-clockwise me-2 text-danger"></i>X√°c Nh·∫≠n Reset Card</h10>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p>B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset card n√†y kh√¥ng?</p>
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    <strong>L∆∞u √Ω:</strong> X√≥a t·∫•t c·∫£ th√¥ng tin,l·ªãch s·ª≠ card:
                    <ul class="mb-10 mt-10">
                        <li>Th√¥ng tin t√†i kho·∫£n ch√≠nh v√† ph·ª•</li>
                        <li>L·ªãch s·ª≠ qu√©t QR</li>
                        <li>Tr·∫°ng th√°i v√¥ hi·ªáu h√≥a</li>
                        <li>L·ªãch s·ª≠ vi ph·∫°m,c·ª©u t√†i kho·∫£n</li>
                        <li>T·∫•t c·∫£ d·ªØ li·ªáu kh√°c</li>
                    </ul>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirm-reset-btn">Apply</button>
            </div>
        </div>
    </div>
</div>

<style>
    /* ========================================
   FLIP CARD 3D CSS
   ======================================== */

    /* Card wrapper v·ªõi perspective */
    .mxh-card-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        min-height: 140px;
        perspective: 1200px;
    }

    /* Card inner - container cho 2 m·∫∑t */
    .mxh-card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        min-height: 140px;
        transform-style: preserve-3d;
        transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
    }

    /* Card face - front & back */
    .mxh-card-face {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
    }

    /* Front face */
    .mxh-card-face.front {
        transform: rotateY(0deg);
        z-index: 2;
    }

    /* Click v√†o s·ªë card ƒë·ªÉ flip */
    .card-number {
        cursor: pointer;
        transition: color 0.2s;
    }

    .card-number:hover {
        color: #00e0ff !important;
    }

    /* ========================================
   CONTEXT MENU SUBMENU
   ======================================== */

    .mxh-context-menu {
        position: fixed;
        z-index: 10000;
        background: #2c3340;
        border: 1px solid #444a59;
        border-radius: 8px;
        padding: 4px;
        min-width: 200px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .mxh-menu-item {
        padding: 8px 12px;
        color: #e6e6e6;
        cursor: pointer;
        border-radius: 4px;
        transition: background 0.2s;
        position: relative;
        white-space: nowrap;
    }

    .mxh-menu-item:hover {
        background: rgba(0, 224, 255, 0.15);
        color: #00e0ff;
    }

    .mxh-menu-item.has-submenu>span::after {
        content: '‚ñ∂';
        float: right;
        margin-left: 12px;
        font-size: 0.8em;
        opacity: 0.6;
    }

    .mxh-submenu {
        position: absolute;
        left: calc(100% - 2px);
        /* Overlap ƒë·ªÉ gi·ªØ hover */
        top: -4px;
        margin-left: 0;
        display: none;
        background: #2c3340;
        border: 1px solid #444a59;
        border-radius: 8px;
        padding: 4px;
        min-width: 200px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        z-index: 10001;
    }

    .mxh-menu-item.has-submenu:hover>.mxh-submenu,
    .mxh-submenu:hover {
        display: block !important;
    }

    .mxh-submenu .mxh-menu-item {
        padding: 6px 10px;
        font-size: 0.9em;
    }

    /* Nested submenu (submenu b√™n trong submenu) */
    .mxh-submenu .mxh-menu-item.has-submenu>.mxh-submenu {
        position: absolute;
        left: calc(100% - 2px);
        top: -4px;
        display: none;
    }

    .mxh-submenu .mxh-menu-item.has-submenu:hover>.mxh-submenu {
        display: block !important;
    }

    /* ========================================
   BORDER COLORS (Vi·ªÅn Card)
   ======================================== */

    .mxh-border-red {
        border: 2px solid #ff4d4f !important;
        box-shadow: 0 0 0 1px rgba(255, 77, 79, 0.3), 0 0 12px rgba(255, 77, 79, 0.4) !important;
    }

    .mxh-border-orange {
        border: 2px solid #ffa500 !important;
        box-shadow: 0 0 0 1px rgba(255, 165, 0, 0.3), 0 0 12px rgba(255, 165, 0, 0.4) !important;
    }

    .mxh-border-green {
        border: 2px solid #07c160 !important;
        box-shadow: 0 0 0 1px rgba(7, 193, 96, 0.3), 0 0 12px rgba(7, 193, 96, 0.4) !important;
    }

    .mxh-border-white {
        border: 2px solid #ffffff !important;
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.3), 0 0 12px rgba(255, 255, 255, 0.4) !important;
    }

    /* Hide number input spinners */
    .no-spinner {
        appearance: textfield;
    }

    .no-spinner::-webkit-outer-spin-button,
    .no-spinner::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }
</style>

<script>
    // ===== MXH REAL-TIME CONFIGURATION =====
    const MXH_CONFIG = {
        AUTO_REFRESH_INTERVAL: 15000, // Changed from 3000 to 15000ms (15 seconds)
        DEBOUNCE_DELAY: 500, // Debounce for inline editing
        RENDER_BATCH_SIZE: 50, // Cards to render per batch (for smooth rendering)
        ENABLE_AUTO_REFRESH: true // Changed from false to true
    };

    // --- GLOBAL FLAGS ---
    window.interactionPaused = false; // set true khi m·ªü modal/context, false khi ƒë√≥ng
    let _mxhGroupsTick = 0;
    let refreshAbortController;

    // T·ª± d·ª´ng/b·∫≠t auto-refresh theo tr·∫°ng th√°i tab
    document.addEventListener('visibilitychange', () => {
        document.hidden ? stopAutoRefresh() : startAutoRefresh();
    });

    // MXH Global State
    let mxhGroups = [];
    let mxhAccounts = [];
    let currentContextAccountId = null;
    let currentContextCardId = null; // NEW: For card-based context menu
    let autoRefreshTimer = null;
    let isRendering = false;
    let pendingUpdates = false;
    let activeGroupId = null;
    let lastUpdateTime = null; // NEW: Store the timestamp of the last successful data load // null = show all groups, otherwise show specific group only

    // NEW: Card States Management (cardId => { activeAccountId, isFlipped })
    // State ch·ªâ l∆∞u trong memory, kh√¥ng persist qua reload
    const cardStates = new Map();
    const lockedStates = new Map(); // Lock state ƒë·ªÉ prevent override trong qu√° tr√¨nh edit

    // NEW: always normalize cardId to Number for state keys
    function getCardState(cardId) {
        const key = Number(cardId); // <-- normalize
        if (!cardStates.has(key)) {
            // console.log(`üì¶ Creating new state for card ${key}`);
            cardStates.set(key, { activeAccountId: null, isFlipped: false });
        }
        const raw = cardStates.get(key);

        // If locked, force activeAccountId to the locked one
        if (lockedStates.has(key)) {
            const lockedAccountId = lockedStates.get(key);
            return { ...raw, activeAccountId: lockedAccountId };
        }
        return raw;
    }

    function setCardState(cardId, updates, lock = false) {
        const key = Number(cardId); // <-- normalize
        // console.log(`üìù setCardState(${key}):`, JSON.stringify(updates), lock ? 'üîí' : '');

        if (lockedStates.has(key)) {
            // console.warn(`‚ö†Ô∏è Card ${key} state is LOCKED, ignoring update`);
            return;
        }

        const state = getCardState(key); // already normalized
        Object.assign(state, updates);
        cardStates.set(key, state); // re-set not strictly required, but explicit

        if (lock && updates.activeAccountId != null) {
            lockedStates.set(key, updates.activeAccountId);
            // Auto-unlock
            setTimeout(() => lockedStates.delete(key), 2000);
        }
    }

    // ===== PERFORMANCE OPTIMIZATION UTILITIES =====
    // Helper so s√°nh nhanh groups
    const areGroupsEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);

    // Gom render v·ªÅ idle ƒë·ªÉ m∆∞·ª£t
    const scheduleRender = () => (window.requestIdleCallback
        ? requestIdleCallback(() => renderMXHAccounts(), { timeout: 200 })
        : setTimeout(() => renderMXHAccounts(), 50)
    );

    // Debounce function - prevents excessive API calls
    function debounce(func, delay) {
        let timeoutId;
        return function (...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    }

    // Throttle function - ensures function runs at most once per interval
    function throttle(func, interval) {
        let lastCall = 0;
        return function (...args) {
            const now = Date.now();
            if (now - lastCall >= interval) {
                lastCall = now;
                func.apply(this, args);
            }
        };
    }


    // ===== REAL-TIME DATA LOADING WITH SMART UPDATES =====
    // Load MXH data from API with optimized rendering
    async function loadMXHData(forceRender = false) {
        if (window.interactionPaused || document.hidden) return; // (1) ch·∫∑n khi ƒëang t∆∞∆°ng t√°c/·∫©n tab

        // (3) ch·ªëng race-condition
        refreshAbortController?.abort();
        refreshAbortController = new AbortController();
        const { signal } = refreshAbortController;

        try {
            // last_updated_at ‚áí t·ª± build accountsUrl nh∆∞ hi·ªán t·∫°i c·ªßa S·∫øp
            const accountsUrl = lastUpdateTime
                ? `/mxh/api/accounts?last_updated_at=${lastUpdateTime}`
                : '/mxh/api/accounts';

            // (2) gi·∫£m t·∫ßn su·∫•t fetch groups
            const fetchGroupsNow = ((++_mxhGroupsTick % 4) === 1) || forceRender;
            const groupsReq = fetchGroupsNow ? fetch('/mxh/api/groups', { signal }) : Promise.resolve({ ok: false });
            const accountsReq = fetch(accountsUrl, { signal });

            const [groupsResponse, accountsResponse] = await Promise.all([groupsReq, accountsReq]);

            // (4) ch·ªâ render groups n·∫øu thay ƒë·ªïi
            if (groupsResponse && groupsResponse.ok) {
                const newGroups = await groupsResponse.json();
                if (!areGroupsEqual(mxhGroups, newGroups)) {
                    mxhGroups = newGroups;
                    renderGroupsNav();
                }
            }

            let dataChanged = false;

            if (accountsResponse.ok) {
                const delta = await accountsResponse.json();                 // [{...updated accounts...}]
                const accountMap = new Map(mxhAccounts.map(a => [a.id, a])); // quick index
                let touchedAny = false;

                delta.forEach(acc => {
                    const exist = accountMap.get(acc.id);
                    if (!exist || JSON.stringify(exist) !== JSON.stringify(acc)) {
                        accountMap.set(acc.id, acc);
                        touchedAny = true;
                    }
                });

                if (touchedAny) {
                    mxhAccounts = Array.from(accountMap.values());
                    dataChanged = true;
                }
            }

            // (5) render m∆∞·ª£t
            if (forceRender || dataChanged) scheduleRender();

        } catch (err) {
            if (err.name !== 'AbortError') console.error('loadMXHData error:', err);
        }
    }

    // ===== AUTO-REFRESH SYSTEM =====
    function startAutoRefresh() {
        if (!MXH_CONFIG.ENABLE_AUTO_REFRESH) return;

        stopAutoRefresh(); // Clear any existing timer

        autoRefreshTimer = setInterval(async () => {
            await loadMXHData(false); // Don't force render, only if data changed
        }, MXH_CONFIG.AUTO_REFRESH_INTERVAL);

        // console.log('‚úÖ MXH Auto-refresh enabled (every', MXH_CONFIG.AUTO_REFRESH_INTERVAL / 1000, 'seconds)');
    }

    function stopAutoRefresh() {
        if (autoRefreshTimer) {
            clearInterval(autoRefreshTimer);
            autoRefreshTimer = null;
        }
    }

    // Pause auto-refresh when user is interacting (context menu open, modal open, etc.)
    let interactionPaused = false;
    function pauseAutoRefresh() {
        interactionPaused = true;
    }

    function resumeAutoRefresh() {
        interactionPaused = false;
    }

    // Ensure platform group exists
    async function ensurePlatformGroup(platform) {
        const existingGroup = mxhGroups.find(g => g.name.toLowerCase() === platform.toLowerCase());
        if (existingGroup) {
            return existingGroup.id;
        }

        try {
            const response = await fetch('/mxh/api/groups', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: platform.charAt(0).toUpperCase() + platform.slice(1),
                    color: getPlatformColor(platform)
                })
            });

            if (response.ok) {
                const newGroup = await response.json();
                mxhGroups.push(newGroup);
                return newGroup.id;
            } else {
                throw new Error('Failed to create group');
            }
        } catch (error) {
            console.error('Error creating platform group:', error);
            throw error;
        }
    }

    // Get platform color
    function getPlatformColor(platform) {
        const colors = {
            'facebook': '#1877f2',
            'instagram': '#e4405f',
            'twitter': '#1da1f2',
            'zalo': '#0068ff',
            'wechat': '#07c160',
            'telegram': '#0088cc',
            'whatsapp': '#25d366'
        };
        return colors[platform] || '#6c757d';
    }

    function getPlatformIconClass(platform) {
        const p = String(platform || '').toLowerCase();
        return ({
            wechat: 'bi-wechat',
            telegram: 'bi-telegram',
            facebook: 'bi-facebook',
            instagram: 'bi-instagram',
            zalo: 'bi-chat-dots-fill',   // kh√¥ng c√≥ icon Zalo -> d√πng chat
            twitter: 'bi-twitter',
            whatsapp: 'bi-whatsapp'
        }[p]) || 'bi-person-badge';
    }

    // Get next card number (per platform/group)
    async function getNextCardNumber(groupId) {
        // Get all accounts in the same group
        const groupAccounts = mxhAccounts.filter(acc => acc.group_id === groupId);
        const numbers = groupAccounts.map(acc => parseInt(acc.card_name)).filter(n => !isNaN(n));

        if (numbers.length === 0) return 1;

        // Find first available number starting from 1
        for (let i = 1; i <= numbers.length + 1; i++) {
            if (!numbers.includes(i)) {
                return i;
            }
        }
        return Math.max(...numbers) + 1;
    }

    // Toggle group visibility
    // ===== RENDER GROUP NAVIGATION WITH BADGES =====
    function renderGroupsNav() {
        const groupsNavContainer = document.getElementById('mxh-groups-nav');
        if (!groupsNavContainer) return;

        let html = '';

        // Get unique groups from accounts
        const uniqueGroupIds = [...new Set(mxhAccounts.map(acc => acc.group_id).filter(id => id))];

        uniqueGroupIds.forEach(groupId => {
            const group = mxhGroups.find(g => g.id == groupId);
            if (group) {
                // Calculate badge count for this group
                const badgeCount = calculateGroupBadge(groupId);
                const isActive = activeGroupId === groupId;

                html += `
                <button class="btn btn-sm ${isActive ? 'btn-primary' : 'btn-outline-light'}" 
                        onclick="selectGroup('${groupId}')"
                        style="position: relative; ${isActive ? '' : 'border-color: ' + group.color + ';'}">
                    <i class="bi ${group.icon || 'bi-people-fill'}" style="color: ${isActive ? '#fff' : group.color};"></i>
                    ${group.name}
                    ${badgeCount > 0 ? `<span class="group-badge" style="background-color: ${group.color};">${badgeCount}</span>` : ''}
                </button>
            `;
            }
        });

        // Add "All" button
        const isAllActive = activeGroupId === null;
        html = `
        <button class="btn btn-sm ${isAllActive ? 'btn-primary' : 'btn-outline-secondary'}" 
                onclick="selectGroup(null)">
            <i class="bi bi-grid-3x3-gap"></i> T·∫•t C·∫£
        </button>
    ` + html;

        groupsNavContainer.innerHTML = html;

        // Update main MXH nav badge
        updateMainNavBadge();
    }

    // Calculate badge count for a specific group (only count cards with blink animation)
    function calculateGroupBadge(groupId) {
        const now = new Date();
        let count = 0;

        mxhAccounts.forEach(account => {
            if (account.group_id != groupId) return;

            // Check if notice countdown finished (causes blink)
            if (account.notice) {
                const noticeObj = ensureNoticeParsed(account.notice);
                if (noticeObj && noticeObj.enabled && noticeObj.start_at && noticeObj.days) {
                    const startDate = new Date(noticeObj.start_at);
                    const endDate = new Date(startDate.getTime() + noticeObj.days * 24 * 60 * 60 * 1000);
                    if (now >= endDate) {
                        count++; // Notice expired = blink
                    }
                }
            }

            // WeChat: Check if account is 1 year old AND NOT Hong Kong number (causes blink)
            if (account.platform === 'wechat' && account.wechat_created_year) {
                const createdDate = new Date(account.wechat_created_year, account.wechat_created_month - 1, account.wechat_created_day);
                const diffDays = Math.ceil((now - createdDate) / (1000 * 60 * 60 * 24));
                if (diffDays >= 365) {
                    // Check if Hong Kong number
                    const primaryPhone = (account.phone || '').replace(/[\s+]/g, '');
                    const isHongKongNumber = primaryPhone.startsWith('852');
                    if (!isHongKongNumber) {
                        count++; // 1 year old + NOT HK number = blink
                    }
                }
            }

            // Check secondary account for WeChat (only if blinks)
            if (account.platform === 'wechat' && account.secondary_wechat_created_year) {
                const secCreatedDate = new Date(account.secondary_wechat_created_year, account.secondary_wechat_created_month - 1, account.secondary_wechat_created_day);
                const secDiffDays = Math.ceil((now - secCreatedDate) / (1000 * 60 * 60 * 24));
                if (secDiffDays >= 365) {
                    // Check if Hong Kong number
                    const secondaryPhone = (account.secondary_phone || '').replace(/[\s+]/g, '');
                    const isHongKongNumber = secondaryPhone.startsWith('852');
                    if (!isHongKongNumber) {
                        count++; // 1 year old + NOT HK number = blink
                    }
                }
            }
        });


        return count;
    }

    // Update badge dots on main MXH nav tab
    function updateMainNavBadge() {
        const mxhNavLink = document.querySelector('a[href*="mxh"]');
        if (!mxhNavLink) return;

        // Remove existing badge container
        const existingBadge = mxhNavLink.querySelector('.nav-badge-container');
        if (existingBadge) existingBadge.remove();

        // Get unique groups that have badges
        const uniqueGroupIds = [...new Set(mxhAccounts.map(acc => acc.group_id).filter(id => id))];
        const groupsWithBadges = [];

        uniqueGroupIds.forEach(groupId => {
            const badgeCount = calculateGroupBadge(groupId);
            if (badgeCount > 0) {
                const group = mxhGroups.find(g => g.id == groupId);
                if (group) {
                    groupsWithBadges.push(group);
                }
            }
        });

        // Create badge dots
        if (groupsWithBadges.length > 0) {
            const badgeContainer = document.createElement('div');
            badgeContainer.className = 'nav-badge-container';

            groupsWithBadges.slice(0, 3).forEach(group => { // Max 3 dots
                const dot = document.createElement('div');
                dot.className = 'nav-badge-dot';
                dot.style.backgroundColor = group.color;
                badgeContainer.appendChild(dot);
            });

            mxhNavLink.appendChild(badgeContainer);
        }
    }

    // Select a specific group (or null for all)
    function selectGroup(groupId) {
        activeGroupId = groupId === 'null' ? null : groupId;
        renderGroupsNav();
        scheduleRender();
    }

    // ===== DATETIME NORMALIZATION HELPERS =====
    // C·∫Øt microseconds v·ªÅ 3 ch·ªØ s·ªë v√† th√™m 'Z' n·∫øu thi·∫øu timezone
    function normalizeISOForJS(iso) {
        if (!iso) return null;
        let s = String(iso).trim();
        // thay ' ' -> 'T' n·∫øu c√≥
        s = s.replace(' ', 'T');
        // N·∫øu c√≥ 'Z' th√¨ ok; n·∫øu c√≥ +00:00 th√¨ v·∫´n ok
        if (!/[zZ]|[+\-]\d{2}:\d{2}$/.test(s)) s += 'Z';
        // Chu·∫©n ho√° ph·∫ßn .xxxxx... v·ªÅ 3 ch·ªØ s·ªë
        s = s.replace(/(\.\d{3})\d+/, '$1'); // gi·ªØ .mmm
        return s;
    }

    function ensureNoticeParsed(notice) {
        let n = (typeof notice === 'string') ? (() => { try { return JSON.parse(notice) } catch { return {} } })() : (notice || {});
        if (n && n.start_at) n.start_at = normalizeISOForJS(n.start_at);
        return n;
    }

    // ===== CARD FACE RENDERING =====
    // Render individual card face with all account details
    function renderCardFace(account, allAccounts, side) {
        const cardId = account.card_id;
        const accountIndex = allAccounts.findIndex(acc => acc.id === account.id) + 1;
        const totalAccounts = allAccounts.length;
        const platform = account.platform || 'unknown';
        const iconClass = getPlatformIconClass(platform);
        const borderClass = getAccountBorderClass(account);
        const now = new Date();

        // === MXH OLD LOGIC: Calculate age and scan countdown ===
        let accountAgeDisplay = '';
        let ageColor = '#fff';
        let scanCountdown = '';

        if (platform === 'wechat' && account.wechat_created_year) {
            const createdDate = new Date(account.wechat_created_year, (account.wechat_created_month || 1) - 1, account.wechat_created_day || 1);
            const diffDays = Math.ceil((now - createdDate) / (1000 * 60 * 60 * 24));

            if (diffDays >= 365) {
                const years = Math.floor(diffDays / 365);
                const months = Math.floor((diffDays % 365) / 30);
                accountAgeDisplay = `${years}nƒÉm ${months}th`;
                ageColor = '#07c160';
            } else if (diffDays >= 30) {
                const months = Math.floor(diffDays / 30);
                accountAgeDisplay = `${months}th ${diffDays % 30}d`;
            } else {
                accountAgeDisplay = `${diffDays}d`;
            }

            // Calculate scan countdown v·ªõi QR icon (MXH OLD logic)
            const currentScanCount = account.wechat_scan_count || 0;
            const maxScans = 3;

            if (currentScanCount >= maxScans) {
                // ƒê√£ h·∫øt l∆∞·ª£t - QR ƒë·ªè
                scanCountdown = `<i class="bi bi-qr-code me-1" style="color: #dc3545;"></i>${maxScans}/${maxScans}`;
            } else if (account.wechat_last_scan_date) {
                // C√≥ l·ªãch s·ª≠ qu√©t - ki·ªÉm tra th·ªùi gian
                const lastScanDate = new Date(account.wechat_last_scan_date);
                const daysSinceScan = Math.floor((now - lastScanDate) / (1000 * 60 * 60 * 24));
                const remainingDays = 30 - daysSinceScan;

                if (remainingDays > 0) {
                    // C√≤n th·ªùi gian ch·ªù - hi·ªÉn th·ªã countdown
                    const hoursSinceScan = Math.floor((now - lastScanDate) / (1000 * 60 * 60));
                    const remainingHours = (30 * 24) - hoursSinceScan;

                    if (remainingHours < 24) {
                        scanCountdown = `<i class="bi bi-qr-code me-1" style="color: #ffffff;"></i>${currentScanCount}/${maxScans} <small class="text-warning">(${remainingHours}h)</small>`;
                    } else {
                        scanCountdown = `<i class="bi bi-qr-code me-1" style="color: #ffffff; font-size: 1.3em;"></i>${currentScanCount}/${maxScans} <small class="text-warning">(${remainingDays}d)</small>`;
                    }
                } else {
                    // ƒê·ªß ƒëi·ªÅu ki·ªán qu√©t ti·∫øp - QR xanh
                    scanCountdown = `<i class="bi bi-qr-code me-1" style="color: #07c160; font-size: 1.3em;"></i>${currentScanCount}/${maxScans}`;
                }
            } else {
                // Ch∆∞a qu√©t l·∫ßn n√†o
                if (diffDays < 90) {
                    scanCountdown = `C√≤n ${90 - diffDays} ng√†y`;
                } else {
                    // ƒê·ªß ƒëi·ªÅu ki·ªán qu√©t l·∫ßn ƒë·∫ßu - QR xanh
                    scanCountdown = `<i class="bi bi-qr-code me-1" style="color: #07c160; font-size: 1.3em;"></i>${currentScanCount}/${maxScans}`;
                }
            }
        }

        // Determine status icon
        let statusIcon = '';
        if (account.status === 'die') {
            statusIcon = '<i class="bi bi-x-circle-fill status-icon" style="color: #dc3545;"></i>';
        } else if (account.status === 'disabled') {
            statusIcon = '<i class="bi bi-slash-circle status-icon" style="color: #ff8c00;"></i>';
        }

        // === Th√¥ng b√°o logic (t·ª´ MXH OLD) ===
        let noticeHtml = '';
        let extraClass = '';
        let tipHtml = '';

        try {
            const noticeObj = typeof account.notice === 'string' ? JSON.parse(account.notice || '{}') : (account.notice || {});
            const hasNotice = noticeObj && (noticeObj.enabled === true || noticeObj.enabled === 1 || Number(noticeObj.days) > 0);

            // Debug: log notice object
            if (noticeObj && Object.keys(noticeObj).length > 0) {
                console.log('Notice for account', account.id, ':', noticeObj, 'hasNotice:', hasNotice);
            }

            if (hasNotice) {
                const dueDate = new Date(noticeObj.due_date || noticeObj.dueDate);
                if (dueDate instanceof Date && !isNaN(dueDate)) {
                    const today = new Date();
                    const remainTime = dueDate - today;
                    const remainDays = Math.ceil(remainTime / (1000 * 60 * 60 * 24));

                    if (remainTime > 0) {
                        let timeDisplay = '';
                        if (remainDays >= 30) {
                            const remainMonths = Math.floor(remainDays / 30);
                            timeDisplay = `${remainMonths}m`;
                        } else {
                            timeDisplay = `${remainDays}d`;
                        }
                        noticeHtml = `<div class="notice-line" style="font-size: 0.75rem; color: #ff9500; margin-top: 4px;">${escapeHtml(noticeObj.title || 'Th√¥ng b√°o')}: ${timeDisplay}</div>`;
                    } else {
                        noticeHtml = `<div class="notice-line expired" style="font-size: 0.75rem; color: #ff4d4f; margin-top: 4px;">${escapeHtml(noticeObj.title || 'Th√¥ng b√°o')}: ƒë√£ ƒë·∫øn h·∫°n</div>`;
                        extraClass = 'notice-expired-blink';
                    }

                    // Tooltip
                    let tooltipTime;
                    if (remainDays >= 30) {
                        const months = Math.floor(remainDays / 30);
                        tooltipTime = `${months}m`;
                    } else {
                        tooltipTime = `${remainDays}d`;
                    }
                    tipHtml = `<div class="notice-tooltip"><div class="notice-tooltip-title">${escapeHtml(noticeObj.title || 'Th√¥ng b√°o')} ‚Äì ${tooltipTime}</div><div class="notice-tooltip-note">${escapeHtml(noticeObj.note || '')}</div></div>`;
                }
            }
        } catch (e) {
            console.error('Error parsing notice:', e);
        }

        // ===== Hi·ªÉn th·ªã khi disabled ======
        let disabledInfo = '';
        const isDisabled = account.status === 'disabled';
        if (isDisabled && platform === 'wechat') {
            let disableDays = 0;
            if (account.die_date) {
                disableDays = Math.ceil((now - new Date(account.die_date)) / (1000 * 60 * 60 * 24));
            }
            disabledInfo = `
                <div style="font-size: 0.75rem; margin-top: 4px;">
                    <div class="d-flex align-items-center justify-content-between">
                        <small class="text-warning">Ng√†y: ${disableDays}</small>
                        <small>L∆∞·ª£t c·ª©u: <span class="text-danger">${account.rescue_count || 0}</span>-<span class="text-success">${account.rescue_success_count || 0}</span></small>
                    </div>
                </div>
            `;
        }

        return `
            <div class="mxh-card-face ${side}">
                <div class="card tool-card mxh-card ${borderClass} ${extraClass}"
                     oncontextmenu="handleCardContextMenu(event, ${cardId}, ${account.id}, '${platform}'); return false;"
                     style="height: 100%; margin: 0;">
                    <div class="card-body" style="display: flex; flex-direction: column; justify-content: space-between; height: 100%;">
                        <div>
                            <div class="d-flex align-items-center justify-content-between mb-1">
                                <div class="d-flex align-items-center gap-1">
                                    <h6 class="card-title mb-0 card-number" 
                                        onclick="event.stopPropagation(); flipCardToAccount(${cardId}, ${account.id}); return false;"
                                        style="font-size: 1.26rem; font-weight: 600;"
                                        title="Click ƒë·ªÉ flip card">
                                        ${account.card_name}
                                    </h6>
                                    <i class="bi ${iconClass}" title="${platform}" style="font-size: 0.9rem; color: ${getPlatformColor(platform)};"></i>
                                    ${totalAccounts > 1 ? `<span class="badge bg-secondary" style="font-size: 0.65rem;">${accountIndex}/${totalAccounts}</span>` : ''}
                                </div>
                                <div class="d-flex align-items-center gap-1">
                                    ${accountAgeDisplay ? `<small style="color: ${ageColor}; font-size: 0.7rem; font-weight: 500;">${accountAgeDisplay}</small>` : ''}
                                </div>
                            </div>
                            
                            <div class="text-center">
                                <div>
                                    <small 
                                        contenteditable="true" 
                                        class="editable-field" 
                                        data-field="username" 
                                        data-account-id="${account.id}"
                                        style="font-size: 0.84rem; cursor: text; border-bottom: 1px dashed transparent; display: inline;"
                                        onblur="saveInlineEdit(this, ${account.id}, 'username')"
                                        onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur();}"
                                        onfocus="this.style.borderBottom='1px dashed #007bff'"
                                        title="Click ƒë·ªÉ ch·ªânh s·ª≠a">${account.username || '...'}</small>${statusIcon}
                                </div>
                                <small 
                                    contenteditable="true" 
                                    class="editable-field text-muted" 
                                    data-field="phone" 
                                    data-account-id="${account.id}"
                                    style="font-size: 0.84rem; display: block; cursor: text; border-bottom: 1px dashed transparent;"
                                    onblur="saveInlineEdit(this, ${account.id}, 'phone')"
                                    onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur();}"
                                    onfocus="this.style.borderBottom='1px dashed #007bff'"
                                    title="Click ƒë·ªÉ ch·ªânh s·ª≠a">üìû ${account.phone || '...'}</small>
                            </div>
                        </div>
                        
                        <div>
                            ${platform === 'wechat' ? `
                                <div class="text-center mt-1">
                                    ${isDisabled ? disabledInfo : `<small style="font-size: 0.75rem;">${scanCountdown}</small>`}
                                </div>
                            ` : ''}
                            ${noticeHtml}
                            ${tipHtml}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    // ===== OPTIMIZED RENDERING WITH SCROLL PRESERVATION =====
    // Render MXH Accounts with performance optimizations and scroll position preservation
    function renderMXHAccounts() {
        console.log('üé® renderMXHAccounts() called from:', new Error().stack.split('\n')[2].trim());

        if (isRendering) {
            pendingUpdates = true;
            return;
        }

        isRendering = true;
        const container = document.getElementById('mxh-accounts-container');

        // üíæ SAVE SCROLL POSITION BEFORE RENDER
        const scrollY = window.scrollY || window.pageYOffset;
        const scrollX = window.scrollX || window.pageXOffset;

        // Filter by active group
        const filteredAccounts = activeGroupId
            ? mxhAccounts.filter(acc => String(acc.group_id) === String(activeGroupId))
            : mxhAccounts;

        if (filteredAccounts.length === 0) {
            container.innerHTML = `
            <div class="card">
                <div class="card-body text-center text-muted">
                    <i class="bi bi-share-fill" style="font-size: 3rem; opacity: 0.3;"></i>
                    <h5 class="mt-3">Ch∆∞a c√≥ t√†i kho·∫£n MXH n√†o</h5>
                    <p>Nh·∫•n "Th√™m T√†i Kho·∫£n MXH" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>
                </div>
            </div>
        `;
            isRendering = false;
            return;
        }

        // === NEW: Group accounts by card_id (1 card ‚Üí N accounts) ===
        const cardGroups = {};
        filteredAccounts.forEach(acc => {
            const cardId = acc.card_id;
            if (!cardGroups[cardId]) {
                cardGroups[cardId] = [];
            }
            cardGroups[cardId].push(acc);
        });

        // Sort accounts within each card (primary first)
        Object.values(cardGroups).forEach(accounts => {
            accounts.sort((a, b) => {
                if (a.is_primary && !b.is_primary) return -1;
                if (!a.is_primary && b.is_primary) return 1;
                return a.id - b.id;
            });
        });

        // Sort cards by card_name numerically
        const sortedCards = Object.entries(cardGroups).sort(([, accountsA], [, accountsB]) => {
            const nameA = parseInt(accountsA[0].card_name, 10) || Infinity;
            const nameB = parseInt(accountsB[0].card_name, 10) || Infinity;
            return nameA - nameB;
        });

        // === Render Cards (1 card per card_id) ===
        let html = '<div class="row g-2">';

        sortedCards.forEach(([cardId, accounts]) => {
            const cid = Number(cardId);                // ‚úÖ normalize
            const state = getCardState(cid);           // d√πng cid
            const primaryAccount = accounts.find(a => a.is_primary) || accounts[0];

            let activeAccount = null;
            if (state.activeAccountId !== null) {
                // account id lu√¥n l√† Number, an to√†n so s√°nh ===
                activeAccount = accounts.find(acc => acc.id === state.activeAccountId);
            }

            if (!activeAccount) {
                if (state.activeAccountId === null) {
                    const currentPrimaryId = primaryAccount ? primaryAccount.id : null;
                    setCardState(cid, { activeAccountId: currentPrimaryId }); // d√πng cid
                    activeAccount = primaryAccount;
                    // log tu·ª≥ ch·ªçn...
                } else {
                    // Hi·ªÉn th·ªã t·∫°m primary, KH√îNG ghi ƒë√® state ƒë√£ c√≥
                    activeAccount = primaryAccount;
                }
            }

            // activeAccount b√¢y gi·ªù ch·∫Øc ch·∫Øn l√† t√†i kho·∫£n h·ª£p l·ªá ƒë·ªÉ hi·ªÉn th·ªã
            const borderClass = getAccountBorderClass(activeAccount);

            html += `
                <div class="col" style="padding: 2px;" data-card-id="${cardId}">
                    <div class="mxh-card-wrapper ${state.isFlipped ? 'flipped' : ''}" id="card-wrapper-${cardId}">
                        <div class="mxh-card-inner">
                            ${renderCardFace(activeAccount, accounts, 'front')}
                            <!-- M·∫∑t sau ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi click chuy·ªÉn account -->
                        </div>
                    </div>
                </div>
            `;
        });

        html += '</div>';
        container.innerHTML = html;

        // Restore scroll position
        window.scrollTo(scrollX, scrollY);

        isRendering = false;

        if (pendingUpdates) {
            pendingUpdates = false;
            scheduleRender();
        }
    }

    // Helper: Get border class based on account status
    function getAccountBorderClass(account) {
        const status = String(account.status || '').toLowerCase();

        // Disabled = m√†u cam
        if (status === 'disabled') {
            return 'mxh-border-orange';
        }

        // Die = m√†u ƒë·ªè
        if (status === 'die' || !!account.die_date) {
            return 'mxh-border-red';
        }

        // Check > 1 year (WeChat)
        if (account.platform === 'wechat' && account.wechat_created_year) {
            const now = new Date();
            const createdDate = new Date(
                account.wechat_created_year,
                (account.wechat_created_month || 1) - 1,
                account.wechat_created_day || 1
            );
            const diffDays = Math.ceil((now - createdDate) / (1000 * 60 * 60 * 24));
            if (diffDays >= 365) {
                const isHK = /^\+?852/.test(account.phone || '');
                return isHK ? 'mxh-border-green' : 'mxh-border-white';
            }
        }

        return ''; // Default - no special border
    }

    // === NEW: Flip Card Function (Single Flip Animation) ===
    function flipCardToAccount(cardId, accountId) {
        const state = getCardState(cardId);
        const wrapper = document.getElementById(`card-wrapper-${cardId}`);
        const cardInner = wrapper?.querySelector('.mxh-card-inner');
        if (!wrapper || !cardInner) return;

        // Do nothing if clicking the currently active account
        if (state.activeAccountId === accountId) {
            return;
        }

        // 1. Get the new account data
        const accounts = mxhAccounts.filter(acc => Number(acc.card_id) === Number(cardId));
        const newActiveAccount = accounts.find(acc => acc.id === accountId);
        if (!newActiveAccount) return;

        // 2. Update the state (save to sessionStorage)
        setCardState(cardId, { activeAccountId: accountId });

        // 3. Start the flip-out animation
        cardInner.style.transform = 'rotateY(90deg)';

        // 4. After half the animation, swap the content and flip back in
        setTimeout(() => {
            // Render the new face directly into the inner container
            cardInner.innerHTML = renderCardFace(newActiveAccount, accounts, 'front');

            // Prepare for flip-in animation
            cardInner.style.transform = 'rotateY(-90deg)';

            // Force a reflow to apply the transform before the next animation frame
            void cardInner.offsetWidth;

            // 5. Flip back in to 0 degrees
            cardInner.style.transition = 'transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1)';
            cardInner.style.transform = 'rotateY(0deg)';

        }, 300); // Half of the total 0.6s animation
    }

    // Helper function for notice configuration
    function configureNoticeToggleFor(menuId, account) {
        const el = document.querySelector(`#${menuId} [id$="-notice-toggle"]`);
        if (!el) return;
        const noticeObj = ensureNoticeParsed(account.notice);
        const hasNotice = !!(noticeObj && noticeObj.enabled);
        // set action + icon + text
        el.dataset.action = hasNotice ? 'clear-notice' : 'set-notice';
        el.innerHTML = hasNotice
            ? '<i class="bi bi-bell-slash-fill me-2"></i> H·ªßy th√¥ng b√°o'
            : '<i class="bi bi-bell-fill me-2"></i> Th√¥ng b√°o';
    }

    // Handle Card Context Menu - Use Unified Menu
    // === NEW: Card-based Context Menu v·ªõi Submenu ===
    window.handleCardContextMenu = function (event, cardId, accountId, platform) {
        event.preventDefault();
        event.stopPropagation();

        currentContextCardId = cardId;
        currentContextAccountId = accountId;
        pauseAutoRefresh();

        const account = mxhAccounts.find(acc => acc.id === accountId);
        if (!account) return;

        // Get all accounts on this card
        const cardAccounts = mxhAccounts.filter(acc => Number(acc.card_id) === Number(cardId));
        const state = getCardState(cardId);
        const isPrimary = account.is_primary;
        const currentStatus = (account.status || 'active').toLowerCase();

        // Parse notice if it's a string
        let noticeObj = null;
        try {
            noticeObj = typeof account.notice === 'string' ? JSON.parse(account.notice || '{}') : (account.notice || {});
        } catch (e) {
            noticeObj = {};
        }
        const hasNotice = noticeObj && (noticeObj.enabled === true || noticeObj.enabled === 1 || Number(noticeObj.days) > 0);

        // Create context menu dynamically
        const menuHtml = `
            <div class="mxh-context-menu" id="card-context-menu">
                <!-- 1. T√†i Kho·∫£n -->
                <div class="mxh-menu-item has-submenu">
                    <span>T√†i Kho·∫£n (${cardAccounts.length})</span>
                    <div class="mxh-submenu">
                        ${cardAccounts.map((acc, idx) => {
            const isActive = acc.id === state.activeAccountId;
            const isPrimary = acc.is_primary;
            return `
                            <div class="mxh-menu-item" data-action="switch-account" data-account-id="${acc.id}">
                                ${isActive ? '‚úì ' : ''}${idx + 1}. ${acc.username || '...'} ${isPrimary ? 'üëë' : ''}
                            </div>
                        `;
        }).join('')}
                        <div class="mxh-menu-item" data-action="add-sub-account" style="border-top: 1px solid #444a59; margin-top: 4px; padding-top: 4px;">
                            <i class="bi bi-plus-circle me-2"></i>Th√™m T√†i Kho·∫£n
                        </div>
                    </div>
                </div>

                <!-- 2. Th√¥ng tin -->
                <div class="mxh-menu-item" data-action="edit">
                    <i class="bi bi-pencil me-2"></i>Th√¥ng Tin
                </div>

                <!-- 3. Tr·∫°ng Th√°i (WeChat only) -->
                ${platform === 'wechat' ? `
                <div class="mxh-menu-item has-submenu wechat-only">
                    <span>Tr·∫°ng Th√°i</span>
                    <div class="mxh-submenu">
                        ${currentStatus === 'disabled' ? `
                            <!-- Khi ƒë√£ disabled, ch·ªâ hi·ªÉn th·ªã 2 option c·ª©u -->
                            <div class="mxh-menu-item" data-action="rescue-success">ƒê∆∞·ª£c C·ª©u</div>
                            <div class="mxh-menu-item" data-action="rescue-failed">C·ª©u Th·∫•t B·∫°i</div>
                        ` : `
                            <!-- Khi ch∆∞a disabled, hi·ªÉn th·ªã 3 tr·∫°ng th√°i b√¨nh th∆∞·ªùng -->
                            <div class="mxh-menu-item" data-action="status-active">${currentStatus === 'active' ? '‚úì ' : ''}Active</div>
                            <div class="mxh-menu-item" data-action="status-disabled">Disabled</div>
                            <div class="mxh-menu-item" data-action="status-die">${currentStatus === 'die' ? '‚úì ' : ''}Die</div>
                        `}
                    </div>
                </div>
                ` : ''}

                <!-- 4. Copy SƒêT -->
                ${account.phone ? `
                <div class="mxh-menu-item" data-action="copy-phone">
                    <i class="bi bi-phone me-2"></i>Copy SƒêT
                </div>
                ` : ''}

                <!-- 5. Qu√©t WeChat (WeChat only) -->
                ${platform === 'wechat' ? `
                <div class="mxh-menu-item has-submenu wechat-only">
                    <span><i class="bi bi-qr-code me-2"></i>Qu√©t WeChat</span>
                    <div class="mxh-submenu">
                        <div class="mxh-menu-item" data-action="scan-wechat">
                            <i class="bi bi-check-circle me-2"></i>ƒê√£ Qu√©t
                        </div>
                        <div class="mxh-menu-item" data-action="reset-scan">
                            <i class="bi bi-arrow-counterclockwise me-2"></i>Reset L∆∞·ª£t Qu√©t
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- 6. Th√¥ng b√°o -->
                <div class="mxh-menu-item" data-action="${hasNotice ? 'cancel-notice' : 'toggle-notice'}">
                    ${hasNotice
                ? '<i class="bi bi-bell-slash-fill me-2"></i>H·ªßy Th√¥ng B√°o'
                : '<i class="bi bi-bell me-2"></i>Th√¥ng B√°o'}
                </div>

                <!-- X√≥a -->
                <div class="mxh-menu-item" data-action="delete" style="color: #ff4d4f; border-top: 1px solid #444a59; margin-top: 4px; padding-top: 4px;">
                    <i class="bi bi-trash me-2"></i>${isPrimary ? 'X√≥a Card' : 'X√≥a Acc'}
                </div>
            </div>
        `;

        // Remove existing menu
        const existingMenu = document.getElementById('card-context-menu');
        if (existingMenu) existingMenu.remove();

        // Add new menu
        document.body.insertAdjacentHTML('beforeend', menuHtml);

        // Smart positioning
        const menu = document.getElementById('card-context-menu');
        positionContextMenuSmart(menu, event.pageX, event.pageY);

        // Position submenus
        setTimeout(() => positionAllSubmenusForMenu(menu), 50);

        // Add click handler
        setTimeout(() => {
            document.addEventListener('click', hideCardContextMenu, { once: true });
        }, 100);
    }

    // Smart positioning function
    function positionContextMenuSmart(menu, x, y) {
        if (!menu) return;

        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Default position
        let left = x;
        let top = y;

        // Check right overflow
        if (x + menuRect.width > viewportWidth) {
            left = viewportWidth - menuRect.width - 10;
        }

        // Check bottom overflow
        if (y + menuRect.height > viewportHeight) {
            top = viewportHeight - menuRect.height - 10;
        }

        // Check left overflow
        if (left < 0) left = 10;

        // Check top overflow
        if (top < 0) top = 10;

        menu.style.left = left + 'px';
        menu.style.top = top + 'px';
    }

    // Position all submenus for a menu
    function positionAllSubmenusForMenu(menu) {
        if (!menu) return;

        const submenuItems = menu.querySelectorAll('.mxh-menu-item.has-submenu');
        submenuItems.forEach(item => {
            const submenu = item.querySelector('.mxh-submenu');
            if (!submenu) return;

            const itemRect = item.getBoundingClientRect();
            const submenuRect = submenu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Default: right side
            submenu.style.left = '100%';
            submenu.style.right = 'auto';
            submenu.style.top = '0';
            submenu.style.bottom = 'auto';

            // Check right overflow - show on left
            if (itemRect.right + submenuRect.width > viewportWidth) {
                submenu.style.left = 'auto';
                submenu.style.right = '100%';
            }

            // Check bottom overflow - show upward
            if (itemRect.top + submenuRect.height > viewportHeight) {
                submenu.style.top = 'auto';
                submenu.style.bottom = '0';
            }
        });
    }

    function hideCardContextMenu() {
        const menu = document.getElementById('card-context-menu');
        if (menu) menu.remove();
        resumeAutoRefresh();
    }

    // Context menu click handler
    document.addEventListener('click', async function (e) {
        const menuItem = e.target.closest('.mxh-menu-item[data-action]');
        if (!menuItem) return;

        e.preventDefault();
        e.stopPropagation();

        const action = menuItem.getAttribute('data-action');

        if (action === 'switch-account') {
            const accountId = parseInt(menuItem.getAttribute('data-account-id'));
            if (currentContextCardId && accountId) {
                flipCardToAccount(currentContextCardId, accountId);
                hideCardContextMenu();
            }
        } else if (action === 'add-sub-account') {
            if (currentContextCardId) {
                await createSubAccount(currentContextCardId);
                hideCardContextMenu();
            }
        } else if (action === 'status-active' || action === 'status-die') {
            const newStatus = action.replace('status-', '');
            if (currentContextAccountId) {
                await updateAccountStatusNew(currentContextAccountId, newStatus);
                hideCardContextMenu();
            }
        } else if (action === 'status-disabled') {
            // Ch·ªâ ƒë·ªïi sang disabled, kh√¥ng hide menu (ƒë·ªÉ hi·ªÉn th·ªã submenu)
            if (currentContextAccountId) {
                await updateAccountStatusNew(currentContextAccountId, 'disabled');
                hideCardContextMenu();
            }
        } else if (action === 'rescue-success' || action === 'rescue-failed') {
            const result = action === 'rescue-success' ? 'success' : 'failed';
            if (currentContextAccountId) {
                await rescueAccountAction(currentContextAccountId, result);
                hideCardContextMenu();
            }
        } else if (action === 'scan-wechat') {
            if (currentContextAccountId) {
                await scanWeChatAccount(currentContextAccountId);
                hideCardContextMenu();
            }
        } else if (action === 'reset-scan') {
            if (currentContextAccountId) {
                await resetScanCountNew(currentContextAccountId);
                hideCardContextMenu();
            }
        } else if (action === 'delete') {
            // Check if it's primary account
            const account = mxhAccounts.find(acc => acc.id === currentContextAccountId);
            if (account && account.is_primary) {
                // Delete entire card
                if (currentContextCardId) {
                    await deleteCard(currentContextCardId);
                    hideCardContextMenu();
                }
            } else {
                // Delete only this account
                if (currentContextAccountId) {
                    await deleteSubAccount(currentContextAccountId);
                    hideCardContextMenu();
                }
            }
        } else if (action === 'edit') {
            if (currentContextAccountId) {
                openAccountModalForEdit(currentContextAccountId);
                hideCardContextMenu();
            }
        } else if (action === 'copy-phone') {
            const account = mxhAccounts.find(acc => acc.id === currentContextAccountId);
            if (account && account.phone) {
                navigator.clipboard.writeText(account.phone);
                if (typeof showToast === 'function') {
                    showToast(`ƒê√£ copy: ${account.phone}`, 'success');
                }
            }
            hideCardContextMenu();
        } else if (action === 'toggle-notice') {
            if (currentContextAccountId) {
                openNoticeModal(null); // S·ª≠ d·ª•ng function c√≥ s·∫µn
                hideCardContextMenu();
            }
        } else if (action === 'cancel-notice') {
            if (currentContextAccountId) {
                await cancelNotice(currentContextAccountId);
                hideCardContextMenu();
            }
        }
    });

    // === NEW: Create Sub-Account ===
    async function createSubAccount(cardId) {
        try {
            const response = await fetch(`/mxh/api/cards/${cardId}/accounts`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({})
            });

            if (response.ok) {
                const newAccount = await response.json();
                mxhAccounts.push(newAccount);

                // Flip to new account
                flipCardToAccount(cardId, newAccount.id);

                if (typeof showToast === 'function') {
                    showToast('ƒê√£ t·∫°o t√†i kho·∫£n ph·ª•!', 'success');
                }
            } else {
                throw new Error('Failed to create sub-account');
            }
        } catch (error) {
            console.error('Error creating sub-account:', error);
            if (typeof showToast === 'function') {
                showToast('L·ªói t·∫°o t√†i kho·∫£n ph·ª•!', 'error');
            }
        }
    }

    // === NEW: Delete Card (v√† t·∫•t c·∫£ accounts) ===
    async function deleteCard(cardId) {
        if (!confirm('X√≥a card n√†y v√† t·∫•t c·∫£ t√†i kho·∫£n tr√™n card?')) return;

        try {
            const response = await fetch(`/mxh/api/cards/${cardId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                // Remove from local state
                mxhAccounts = mxhAccounts.filter(acc => acc.card_id !== cardId);
                cardStates.delete(cardId);
                scheduleRender();
                if (typeof showToast === 'function') {
                    showToast('ƒê√£ x√≥a card!', 'success');
                }
            } else {
                throw new Error('Failed to delete card');
            }
        } catch (error) {
            console.error('Error deleting card:', error);
            if (typeof showToast === 'function') {
                showToast('L·ªói x√≥a card!', 'error');
            }
        }
    }

    // === NEW: Delete Sub-Account ===
    async function deleteSubAccount(accountId) {
        if (!confirm('X√≥a t√†i kho·∫£n ph·ª• n√†y?')) return;

        try {
            const response = await fetch(`/mxh/api/sub_accounts/${accountId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                // Remove from local state
                mxhAccounts = mxhAccounts.filter(acc => acc.id !== accountId);
                scheduleRender();
                if (typeof showToast === 'function') {
                    showToast('ƒê√£ x√≥a t√†i kho·∫£n ph·ª•!', 'success');
                }
            } else {
                throw new Error('Failed to delete sub-account');
            }
        } catch (error) {
            console.error('Error deleting sub-account:', error);
            if (typeof showToast === 'function') {
                showToast('L·ªói x√≥a t√†i kho·∫£n ph·ª•!', 'error');
            }
        }
    }

    // === NEW: Rescue Account Action ===
    async function rescueAccountAction(accountId, result) {
        try {
            const response = await fetch(`/mxh/api/accounts/${accountId}/rescue`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ result })
            });

            if (response.ok) {
                // Update local state
                const accountIndex = mxhAccounts.findIndex(acc => acc.id === accountId);
                if (accountIndex !== -1) {
                    if (result === 'success') {
                        mxhAccounts[accountIndex].status = 'active';
                        mxhAccounts[accountIndex].die_date = null;
                        mxhAccounts[accountIndex].rescue_success_count = (mxhAccounts[accountIndex].rescue_success_count || 0) + 1;
                    } else {
                        mxhAccounts[accountIndex].rescue_count = (mxhAccounts[accountIndex].rescue_count || 0) + 1;
                    }
                }

                scheduleRender();
                const message = result === 'success' ? '‚úÖ C·ª©u th√†nh c√¥ng!' : 'üìù ƒê√£ ghi nh·∫≠n c·ª©u th·∫•t b·∫°i!';
                if (typeof showToast === 'function') {
                    showToast(message, 'success');
                }
            } else {
                throw new Error('Failed to rescue account');
            }
        } catch (error) {
            console.error('Error rescuing account:', error);
            if (typeof showToast === 'function') {
                showToast('L·ªói khi c·ª©u t√†i kho·∫£n!', 'error');
            }
        }
    }

    // === NEW: Scan WeChat Account ===
    async function scanWeChatAccount(accountId) {
        // Instant local update
        const accountIndex = mxhAccounts.findIndex(acc => acc.id === accountId);
        if (accountIndex !== -1) {
            mxhAccounts[accountIndex].wechat_scan_count = (mxhAccounts[accountIndex].wechat_scan_count || 0) + 1;
            mxhAccounts[accountIndex].wechat_last_scan_date = new Date().toISOString();
            scheduleRender();
        }

        try {
            const response = await fetch(`/mxh/api/accounts/${accountId}/scan`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });

            if (response.ok) {
                // Merge server response if available
                const responseData = await response.json();
                if (responseData && responseData.id) {
                    const idx = mxhAccounts.findIndex(acc => acc.id === accountId);
                    if (idx !== -1) {
                        mxhAccounts[idx] = responseData;
                        scheduleRender();
                    }
                }

                if (typeof showToast === 'function') {
                    showToast('‚úÖ ƒê√£ ghi nh·∫≠n qu√©t WeChat!', 'success');
                }
            } else {
                throw new Error('Failed to record scan');
            }
        } catch (error) {
            console.error('Error scanning WeChat:', error);
            if (typeof showToast === 'function') {
                showToast('L·ªói khi qu√©t WeChat!', 'error');
            }
        }
    }


    // === NEW: Update Account Status v·ªõi die_date persist ===
    async function updateAccountStatusNew(accountId, status) {
        try {
            const payload = { status };

            // If status is die, set die_date
            if (status === 'die') {
                payload.die_date = new Date().toISOString().split('T')[0];
            } else {
                payload.die_date = null;
            }

            const response = await fetch(`/mxh/api/accounts/${accountId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                const updatedAccount = await response.json();

                // Update local state
                const index = mxhAccounts.findIndex(acc => acc.id === accountId);
                if (index !== -1) {
                    mxhAccounts[index] = updatedAccount;
                }

                scheduleRender();
                if (typeof showToast === 'function') {
                    showToast(`ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i: ${status}`, 'success');
                }
            } else {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to update status');
            }
        } catch (error) {
            console.error('Error updating status:', error);
            if (typeof showToast === 'function') {
                showToast(`L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i: ${error.message}`, 'error');
            }
        }
    }

    // Notice modal functions
    let noticeTargetId = null;
    function openNoticeModal(event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        if (!currentContextAccountId) return;

        noticeTargetId = currentContextAccountId;
        document.getElementById('noticeTitle').value = 'Reg';
        document.getElementById('noticeDays').value = 7;
        document.getElementById('noticeNote').value = '';

        const modal = new bootstrap.Modal(document.getElementById('noticeModal'));
        modal.show();
    }

    async function submitNotice() {
        const title = document.getElementById('noticeTitle').value.trim();
        const days = parseInt(document.getElementById('noticeDays').value, 10) || 0;
        const note = document.getElementById('noticeNote').value.trim();

        if (!noticeTargetId || !title || days <= 0) {
            showToast('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!', 'error');
            return;
        }

        try {
            // Pause auto-refresh to prevent race condition
            stopAutoRefresh();

            const response = await fetch(`/mxh/api/accounts/${noticeTargetId}/notice`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title, days, note })
            });

            if (response.ok) {
                showToast('‚úÖ ƒê√£ ƒë·∫∑t th√¥ng b√°o!', 'success');
                const modal = bootstrap.Modal.getInstance(document.getElementById('noticeModal'));
                modal.hide();

                // Update local data immediately to trigger render
                const account = mxhAccounts.find(a => a.id === noticeTargetId);
                if (account) {
                    const startDate = new Date();
                    const dueDate = new Date(startDate);
                    dueDate.setDate(dueDate.getDate() + days);

                    account.notice = {
                        enabled: true,
                        title: title,
                        days: days,
                        note: note,
                        start_at: startDate.toISOString(),
                        due_date: dueDate.toISOString()
                    };
                    // console.log('‚úÖ Updated local notice for account', noticeTargetId, account.notice);
                }

                // Force re-render with updated data
                scheduleRender();

                // Resume auto-refresh after render
                setTimeout(() => startAutoRefresh(), 100);
            } else {
                showToast('L·ªói khi ƒë·∫∑t th√¥ng b√°o!', 'error');
                startAutoRefresh(); // Resume even on error
            }
        } catch (error) {
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            startAutoRefresh(); // Resume even on error
        }
        noticeTargetId = null;
    }

    async function clearNotice(event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        if (!currentContextAccountId) return;

        try {
            // Pause auto-refresh to prevent race condition
            stopAutoRefresh();

            const response = await fetch(`/mxh/api/accounts/${currentContextAccountId}/notice`, {
                method: 'DELETE'
            });

            if (response.ok) {
                showToast('‚úÖ ƒê√£ t·∫Øt th√¥ng b√°o!', 'success');

                // Update local data immediately to trigger render
                const account = mxhAccounts.find(a => a.id === currentContextAccountId);
                if (account) {
                    account.notice = null; // Set to null instead of empty object
                    // console.log('‚úÖ Cleared local notice for account', currentContextAccountId);
                }

                // Force re-render with updated data
                scheduleRender();

                // Resume auto-refresh after render
                setTimeout(() => startAutoRefresh(), 100);
            } else {
                showToast('L·ªói khi x√≥a th√¥ng b√°o!', 'error');
                startAutoRefresh(); // Resume even on error
            }
        } catch (error) {
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            startAutoRefresh(); // Resume even on error
        }
    }

    // Alias for cancel notice from context menu
    async function cancelNotice(accountId) {
        currentContextAccountId = accountId;
        await clearNotice(null);
    }

    function escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        };
        return String(text).replace(/[&<>"']/g, m => map[m]);
    }

    // NEW: Reset scan count for new context menu
    async function resetScanCountNew(accountId) {
        if (!accountId) return;

        // Instant local update
        const accountIndex = mxhAccounts.findIndex(acc => acc.id === accountId);
        if (accountIndex !== -1) {
            mxhAccounts[accountIndex].wechat_scan_count = 0;
            mxhAccounts[accountIndex].wechat_last_scan_date = null;
            scheduleRender();
        }

        try {
            const response = await fetch(`/mxh/api/accounts/${accountId}/scan`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reset: true })
            });

            if (response.ok) {
                // Merge server response if available
                const responseData = await response.json();
                if (responseData && responseData.id) {
                    const idx = mxhAccounts.findIndex(acc => acc.id === accountId);
                    if (idx !== -1) {
                        mxhAccounts[idx] = responseData;
                        scheduleRender();
                    }
                }
                showToast('‚úÖ ƒê√£ reset l∆∞·ª£t qu√©t!', 'success');
            } else {
                showToast('L·ªói!', 'error');
                await loadMXHData(false);
            }
        } catch (error) {
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            await loadMXHData(false);
        }
    }

    // Open modal for editing account (WeChat or Generic)
    function openAccountModalForEdit(accountId) {
        currentContextAccountId = accountId;
        const account = mxhAccounts.find(acc => acc.id === accountId);

        if (!account) return;

        // N·∫øu l√† WeChat ‚Üí m·ªü WeChat modal, kh√¥ng th√¨ m·ªü generic modal
        if (account.platform === 'wechat') {
            openWeChatModal(accountId);
        } else {
            // Open generic modal for other platforms
            document.getElementById('generic-username').value = account.login_username || '';
            document.getElementById('generic-password').value = account.login_password || '';
            document.getElementById('generic-display-name').value = account.username || '';
            document.getElementById('generic-phone').value = account.phone || '';
            document.getElementById('generic-url').value = account.url || '';

            const modal = new bootstrap.Modal(document.getElementById('generic-account-modal'));
            modal.show();
        }
    }

    async function deleteAccount(accountId) {
        // Instant local update - remove from array
        const accountIndex = mxhAccounts.findIndex(acc => acc.id === accountId);
        if (accountIndex !== -1) {
            mxhAccounts.splice(accountIndex, 1);
        }
        scheduleRender();

        try {
            const response = await fetch(`/mxh/api/accounts/${accountId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                showToast('‚úÖ ƒê√£ x√≥a card!', 'success');

            } else {
                showToast('L·ªói!', 'error');
                await loadMXHData(false);
            }
        } catch (error) {
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            await loadMXHData(false);
        }
    }

    async function resetAccount(accountId) {
        // Find the account and its card_id
        const accountIndex = mxhAccounts.findIndex(acc => acc.id === accountId);
        if (accountIndex === -1) {
            console.error(`Account ${accountId} not found for reset`);
            return;
        }

        const cardId = mxhAccounts[accountIndex].card_id;

        // Instant local update - reset all data
        const account = mxhAccounts[accountIndex];
        mxhAccounts[accountIndex] = {
            ...account, // Keep all existing fields
            id: account.id,
            card_id: account.card_id,
            platform: account.platform,
            group_id: account.group_id,
            card_name: account.card_name,
            is_primary: account.is_primary,
            // Reset these fields
            username: '.',
            phone: '.',
            status: 'active',
            wechat_scan_count: 0,
            wechat_last_scan_date: null,
            die_date: null,
            rescue_count: 0,
            rescue_success_count: 0,
            notice: null,
            muted_until: null
        };

        // *** CRITICAL: Ensure activeAccountId is set BEFORE rendering ***
        setCardState(cardId, { activeAccountId: accountId });

        scheduleRender();

        try {
            const response = await fetch(`/mxh/api/accounts/${accountId}/reset`, {
                method: 'POST'
            });

            if (response.ok) {
                const updatedAccount = await response.json();
                // Merge server response back into local data
                const idx = mxhAccounts.findIndex(acc => acc.id === accountId);
                if (idx !== -1) {
                    mxhAccounts[idx] = updatedAccount;
                    // *** CRITICAL: Keep the account active after server update ***
                    setCardState(cardId, { activeAccountId: accountId });
                    console.log(`‚úÖ Reset account ${accountId}, keeping it as active for card ${cardId}`);
                    scheduleRender(); // Re-render with server data
                }
                showToast('‚úÖ ƒê√£ reset card!', 'success');
            } else {
                showToast('L·ªói!', 'error');
                await loadMXHData(false);
            }
        } catch (error) {
            console.error('Error resetting account:', error);
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            await loadMXHData(false);
        }
    }

    // Modal Button Handlers with instant updates
    document.getElementById('mxh-save-account-btn').addEventListener('click', async () => {
        const platform = document.getElementById('mxh-platform').value;
        const username = (document.getElementById('mxh-username').value || '.').trim() || '.';
        const password = (document.getElementById('mxh-password')?.value || '.').trim() || '.';
        const phone = (document.getElementById('mxh-phone').value || '.').trim() || '.';
        const url = (document.getElementById('mxh-url').value || '.').trim() || '.';
        const day = parseInt(document.getElementById('mxh-day').value, 10);
        const month = parseInt(document.getElementById('mxh-month').value, 10);
        const year = parseInt(document.getElementById('mxh-year').value, 10);

        // Ch·ªâ b·∫Øt bu·ªôc: N·ªÄN T·∫¢NG + NG√ÄY/TH√ÅNG/NƒÇM (ƒë√£ auto-fill)
        if (!platform || !day || !month || !year) {
            showToast('Ch·ªçn N·ªÅn t·∫£ng v√† Ng√†y t·∫°o!', 'error');
            return;
        }

        try {
            const groupId = await ensurePlatformGroup(platform);
            const autoCardNumber = (await getNextCardNumber(groupId)).toString();

            const res = await fetch('/mxh/api/accounts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    card_name: autoCardNumber,
                    group_id: groupId,
                    platform,
                    username,             // n·∫øu tr·ªëng ƒë√£ l√† "."
                    phone,
                    url,
                    login_username: ".",  // l∆∞u c·∫∑p th√¥ng tin ƒëƒÉng nh·∫≠p ƒë·ªÉ hi·ªán sau n√†y
                    login_password: password,
                    wechat_created_day: day,
                    wechat_created_month: month,
                    wechat_created_year: year
                })
            });

            if (res.ok) {
                showToast('‚úÖ ƒê√£ t·∫°o card!', 'success');
                bootstrap.Modal.getInstance(document.getElementById('mxh-addAccountModal')).hide();
                await loadMXHData(false);
            } else {
                const err = await res.json();
                showToast(err.error || 'L·ªói khi t·∫°o t√†i kho·∫£n!', 'error');
            }
        } catch {
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
        }
    });

    document.getElementById('wechat-apply-btn').addEventListener('click', async () => {
        if (!currentContextAccountId) return;

        const selectedStatus = document.getElementById('wechat-status').value;

        // Get date value from single input and parse it
        const dateValue = document.getElementById('wechat-date').value;
        const dateParts = dateValue.split('/');
        const day = parseInt(dateParts[0]) || 1;
        const month = parseInt(dateParts[1]) || 1;
        const year = parseInt(dateParts[2]) || 2024;

        const data = {
            card_name: document.getElementById('wechat-card-name').value,
            username: document.getElementById('wechat-username').value,
            phone: document.getElementById('wechat-phone').value,
            wechat_created_day: day,
            wechat_created_month: month,
            wechat_created_year: year,
            status: selectedStatus,  // Keep the status as-is: 'active', 'disabled', or 'die'
            wechat_status: selectedStatus
        };

        // Find account and preserve card_id
        const accountIndex = mxhAccounts.findIndex(acc => acc.id === currentContextAccountId);
        if (accountIndex === -1) {
            showToast('L·ªói: Kh√¥ng t√¨m th·∫•y account!', 'error');
            return;
        }

        const cardId = Number(mxhAccounts[accountIndex].card_id);

        // Update local data immediately - preserve ALL existing properties
        Object.assign(mxhAccounts[accountIndex], data);

        // *** CRITICAL: Ensure activeAccountId is set BEFORE rendering ***
        setCardState(cardId, { activeAccountId: currentContextAccountId });
        console.log(`üîß WeChat Apply: Updated account ${currentContextAccountId}, set as active for card ${cardId}`);
        console.log(`   Account exists in mxhAccounts:`, !!mxhAccounts.find(a => a.id === currentContextAccountId));
        console.log(`   Card accounts:`, mxhAccounts.filter(a => a.card_id === cardId).map(a => ({ id: a.id, is_primary: a.is_primary })));

        // Hide modal and re-render (preserves active account)
        bootstrap.Modal.getInstance(document.getElementById('wechat-account-modal')).hide();
        scheduleRender();

        try {
            const response = await fetch(`/mxh/api/accounts/${currentContextAccountId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.ok) {
                const updatedAccount = await response.json();
                // Merge the server response back into local data
                const idx = mxhAccounts.findIndex(acc => acc.id === currentContextAccountId);
                if (idx !== -1) {
                    mxhAccounts[idx] = updatedAccount;
                    // *** CRITICAL: Keep the account active after server update ***
                    setCardState(cardId, { activeAccountId: currentContextAccountId });
                    console.log(`‚úÖ Updated WeChat account ${currentContextAccountId}, keeping it as active for card ${cardId}`);
                    scheduleRender(); // Re-render with server data
                }
                showToast('‚úÖ ƒê√£ c·∫≠p nh·∫≠t!', 'success');
            } else {
                const error = await response.json();
                showToast(error.error || 'L·ªói!', 'error');
                await loadMXHData(false);
            }
        } catch (error) {
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            await loadMXHData(false);
        }
    });

    document.getElementById('generic-account-edit-form').addEventListener('submit', async (e) => {
        e.preventDefault(); // Prevent default form submission (browser refresh)
        if (!currentContextAccountId) return;

        const data = {
            login_username: document.getElementById('generic-username').value,
            login_password: document.getElementById('generic-password').value,
            username: document.getElementById('generic-display-name').value,
            phone: document.getElementById('generic-phone').value,
            url: document.getElementById('generic-url').value
        };

        // Find account and preserve card_id
        const accountIndex = mxhAccounts.findIndex(acc => acc.id === currentContextAccountId);
        if (accountIndex === -1) {
            showToast('L·ªói: Kh√¥ng t√¨m th·∫•y account!', 'error');
            return;
        }

        const cardId = Number(mxhAccounts[accountIndex].card_id);

        // Instant local update
        Object.keys(data).forEach(key => {
            if (data[key] !== undefined && data[key] !== null) {
                mxhAccounts[accountIndex][key] = data[key];
            }
        });

        // *** CRITICAL: Ensure activeAccountId is set BEFORE rendering ***
        setCardState(cardId, { activeAccountId: currentContextAccountId });
        console.log(`üîß Generic Apply: Updated account ${currentContextAccountId}, set as active for card ${cardId}`);
        console.log(`   Account exists in mxhAccounts:`, !!mxhAccounts.find(a => a.id === currentContextAccountId));
        console.log(`   Card accounts:`, mxhAccounts.filter(a => a.card_id === cardId).map(a => ({ id: a.id, is_primary: a.is_primary })));

        bootstrap.Modal.getInstance(document.getElementById('generic-account-modal')).hide();
        scheduleRender();

        try {
            const response = await fetch(`/mxh/api/accounts/${currentContextAccountId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.ok) {
                const updatedAccount = await response.json();
                // Merge the server response back into local data
                const idx = mxhAccounts.findIndex(acc => acc.id === currentContextAccountId);
                if (idx !== -1) {
                    mxhAccounts[idx] = updatedAccount;
                    // *** CRITICAL: Keep the account active after server update ***
                    setCardState(cardId, { activeAccountId: currentContextAccountId });
                    console.log(`‚úÖ Updated generic account ${currentContextAccountId}, keeping it as active for card ${cardId}`);
                    scheduleRender(); // Re-render with server data
                }
                showToast('‚úÖ ƒê√£ c·∫≠p nh·∫≠t!', 'success');
            } else {
                showToast('L·ªói!', 'error');
                await loadMXHData(false);
            }
        } catch (error) {
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            await loadMXHData(false);
        }
    });

    document.getElementById('apply-card-number-btn').addEventListener('click', async () => {
        if (!currentContextAccountId) return;

        const newNumber = document.getElementById('new-card-number').value;
        if (!newNumber) return;

        // Instant local update
        const accountIndex = mxhAccounts.findIndex(acc => acc.id === currentContextAccountId);
        if (accountIndex !== -1) {
            mxhAccounts[accountIndex].card_name = newNumber;
        }

        bootstrap.Modal.getInstance(document.getElementById('change-card-number-modal')).hide();
        scheduleRender();

        try {
            const response = await fetch(`/mxh/api/accounts/${currentContextAccountId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ card_name: newNumber })
            });

            if (response.ok) {
                const updatedAccount = await response.json();
                // Update all accounts with the same card_id to have the new card_name
                const cardId = updatedAccount.card_id;
                mxhAccounts.forEach((acc, idx) => {
                    if (acc.card_id === cardId) {
                        mxhAccounts[idx].card_name = newNumber;
                    }
                });
                scheduleRender();
                showToast('‚úÖ ƒê√£ ƒë·ªïi s·ªë hi·ªáu!', 'success');
            } else {
                showToast('L·ªói!', 'error');
                await loadMXHData(false);
            }
        } catch (error) {
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            await loadMXHData(false);
        }
    });

    document.getElementById('confirm-delete-btn').addEventListener('click', async () => {
        if (!currentContextAccountId) return;
        await deleteAccount(currentContextAccountId);
        bootstrap.Modal.getInstance(document.getElementById('delete-card-modal')).hide();
    });

    // Reset button handlers
    document.getElementById('wechat-reset-btn').addEventListener('click', () => {
        if (!currentContextAccountId) return;
        const modal = new bootstrap.Modal(document.getElementById('reset-card-modal'));
        modal.show();
    });

    document.getElementById('generic-reset-btn').addEventListener('click', () => {
        if (!currentContextAccountId) return;
        const modal = new bootstrap.Modal(document.getElementById('reset-card-modal'));
        modal.show();
    });

    document.getElementById('confirm-reset-btn').addEventListener('click', async () => {
        if (!currentContextAccountId) return;
        await resetAccount(currentContextAccountId);

        // Safely hide modals - check if instance exists first
        const resetModal = bootstrap.Modal.getInstance(document.getElementById('reset-card-modal'));
        if (resetModal) resetModal.hide();

        const wechatModal = bootstrap.Modal.getInstance(document.getElementById('wechat-account-modal'));
        if (wechatModal) wechatModal.hide();

        const genericModal = bootstrap.Modal.getInstance(document.getElementById('generic-account-modal'));
        if (genericModal) genericModal.hide();
    });

    document.getElementById('mxh-apply-view-mode-btn').addEventListener('click', () => {
        const cardsPerRow = document.getElementById('mxh-cards-per-row').value;
        localStorage.setItem('mxh_cards_per_row', cardsPerRow);

        const style = document.getElementById('mxh-dynamic-style') || document.createElement('style');
        style.id = 'mxh-dynamic-style';
        style.innerHTML = `
        #mxh-accounts-container .row > .col {
            flex: 0 0 calc(100% / ${cardsPerRow});
            max-width: calc(100% / ${cardsPerRow});
        }
    `;
        if (!document.getElementById('mxh-dynamic-style')) {
            document.head.appendChild(style);
        }

        showToast(`ƒê√£ √°p d·ª•ng ${cardsPerRow} cards/h√†ng!`, 'success');
        bootstrap.Modal.getInstance(document.getElementById('mxh-view-mode-modal')).hide();
    });

    // Initialize cards per row setting
    (function initializeCardsPerRow() {
        const savedCardsPerRow = localStorage.getItem('mxh_cards_per_row') || 12;
        const cardsPerRowInput = document.getElementById('mxh-cards-per-row');
        if (cardsPerRowInput) {
            cardsPerRowInput.value = savedCardsPerRow;
        }
        const style = document.createElement('style');
        style.id = 'mxh-dynamic-style';
        style.innerHTML = `
        #mxh-accounts-container .row > .col {
            flex: 0 0 calc(100% / ${savedCardsPerRow});
            max-width: calc(100% / ${savedCardsPerRow});
        }
    `;
        document.head.appendChild(style);
    })();


    // Initialize - Load data and start auto-refresh
    document.addEventListener('DOMContentLoaded', async () => {
        // console.log('üöÄ MXH Tab Initializing...');

        // Initial load
        await loadMXHData(true);

        // Start auto-refresh
        startAutoRefresh();

        // Pause auto-refresh when modal is opened
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('show.bs.modal', () => {
                window.interactionPaused = true;
                pauseAutoRefresh();
            });
            modal.addEventListener('hide.bs.modal', () => {
                window.interactionPaused = false;
                resumeAutoRefresh();
            });
        });

        // Handle page visibility changes (pause when tab not visible)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopAutoRefresh();
                // console.log('‚è∏Ô∏è MXH Auto-refresh paused (tab hidden)');
            } else {
                startAutoRefresh();
                loadMXHData(true); // Immediate refresh when tab becomes visible
                // console.log('‚ñ∂Ô∏è MXH Auto-refresh resumed (tab visible)');
            }
        });

        // console.log('‚úÖ MXH Tab Ready - Real-time mode enabled!');
    });


    // Open WeChat Modal Function
    let _openWeChatModalLock = false;
    window.openWeChatModal = function (accountId) {
        if (_openWeChatModalLock) return;
        _openWeChatModalLock = true;

        const account = mxhAccounts.find(acc => acc.id === accountId);
        if (!account) {
            _openWeChatModalLock = false;
            return;
        }

        currentContextAccountId = accountId;

        const modalTitle = document.querySelector('#wechat-account-modal .modal-title');
        modalTitle.innerHTML = '<i class="bi bi-wechat me-2"></i>Th√¥ng Tin T√†i Kho·∫£n';

        document.getElementById('wechat-card-name').value = account.card_name || '';
        document.getElementById('wechat-username').value = account.username || '';
        document.getElementById('wechat-phone').value = account.phone || '';

        // Format date for display
        const day = account.wechat_created_day || 1;
        const month = account.wechat_created_month || 1;
        const year = account.wechat_created_year || 2024;
        document.getElementById('wechat-date').value = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;

        const primaryStatus = account.status || 'active';
        document.getElementById('wechat-status').value = primaryStatus;

        const modal = new bootstrap.Modal(document.getElementById('wechat-account-modal'));
        modal.show();

        setTimeout(() => { _openWeChatModalLock = false; }, 300);
    };

    // ===== INLINE EDITING FUNCTIONS WITH INSTANT UPDATES =====

    // Save inline edit when user clicks away or presses Enter
    window.saveInlineEdit = async function (element, accountId, field) {
        const newValue = element.textContent.trim();

        // Remove emoji and extra characters for phone field
        let cleanValue = newValue;
        if (field === 'phone') {
            cleanValue = newValue.replace(/[üìû\s]/g, '');
        }

        // Get original value from account data
        const account = mxhAccounts.find(acc => acc.id === accountId);
        if (!account) return;

        const originalValue = account[field] || '.';

        // If empty or just "...", set to "."
        if (!cleanValue || cleanValue === '...' || cleanValue === '...') {
            cleanValue = '.';
        }

        // If unchanged, do nothing
        if (cleanValue === originalValue) {
            element.style.borderBottom = '1px dashed transparent';
            return;
        }

        // Update via API
        const success = await quickUpdateField(accountId, field, cleanValue);

        if (success) {
            // Update display with proper format
            if (field === 'phone') {
                element.textContent = `üìû ${cleanValue}`;
            } else {
                element.textContent = cleanValue;
            }
            // Re-render to update all cards showing this account
            scheduleRender();
        } else {
            // Restore original on failure
            if (field === 'phone') {
                element.textContent = `üìû ${originalValue}`;
            } else {
                element.textContent = originalValue;
            }
        }

        element.style.borderBottom = '1px dashed transparent';
    };

    // Quick update field (instant local update, debounced API call)
    async function quickUpdateField(accountId, field, value) {
        try {
            // Find the account first
            const accountIndex = mxhAccounts.findIndex(acc => acc.id === accountId);
            if (accountIndex === -1) {
                console.error(`Account ${accountId} not found`);
                return false;
            }

            const oldValue = mxhAccounts[accountIndex][field];

            // ‚úÖ normalize here
            const cardId = Number(mxhAccounts[accountIndex].card_id);

            // INSTANT LOCAL UPDATE - Update UI immediately
            mxhAccounts[accountIndex][field] = value;

            // *** CRITICAL: Set active account BEFORE rendering AND LOCK IT ***
            setCardState(cardId, { activeAccountId: accountId }, true); // Lock state for 2 seconds
            console.log(`üîß Inline Edit (before API): Set card ${cardId} to show account ${accountId}`);

            scheduleRender();

            // API call in background using the existing PUT endpoint
            const response = await fetch(`/mxh/api/accounts/${accountId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    [field]: value
                })
            });

            if (response.ok) {
                const idx = mxhAccounts.findIndex(acc => acc.id === accountId);
                if (idx !== -1) {
                    const normalizedCardId = Number(mxhAccounts[idx].card_id); // ‚úÖ normalize again
                    const updatedAccount = await response.json();
                    updatedAccount.card_id = normalizedCardId;                 // ensure card_id kept

                    mxhAccounts[idx] = updatedAccount;

                    setCardState(normalizedCardId, { activeAccountId: accountId }, true);
                    scheduleRender();
                }
                showToast(`‚úÖ ƒê√£ l∆∞u ${field === 'username' ? 't√™n' : 'SƒêT'}!`, 'success');
                return true;
            } else {
                // Revert on error
                mxhAccounts[accountIndex][field] = oldValue;
                const error = await response.json();
                showToast(error.error || 'L·ªói khi c·∫≠p nh·∫≠t!', 'error');
                scheduleRender();
                return false;
            }
        } catch (error) {
            console.error('Error in quickUpdateField:', error);
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            await loadMXHData(false); // Reload to get correct data
            return false;
        }
    }

    // Setup contenteditable fields
    function setupEditableFields() {
        const editableFields = document.querySelectorAll('.editable-field');

        editableFields.forEach(field => {
            // Store original value
            field.dataset.originalValue = field.textContent.trim();

            // Handle Enter key - save and blur
            field.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    field.blur();
                }
            });

            // Handle Escape key - cancel and restore
            field.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    field.textContent = field.dataset.originalValue;
                    field.blur();
                }
            });

            // Handle blur - save changes
            field.addEventListener('blur', async (e) => {
                let newValue = e.target.textContent.trim();
                const accountId = parseInt(e.target.dataset.accountId);
                const fieldName = e.target.dataset.field;

                // Remove emoji prefix for phone
                if (fieldName === 'phone') {
                    newValue = newValue.replace(/^üìû\s*/, '').trim();
                }

                // Check if value is the same or if it's just the placeholder being edited (and not real data)
                const isNoChange = newValue === field.dataset.originalValue ||
                    (newValue === '' && field.dataset.originalValue === '.') ||
                    (newValue === 'Click ƒë·ªÉ nh·∫≠p' && field.dataset.originalValue === ''); // NEW CHECK

                if (isNoChange) {
                    // Restore the visual placeholder if needed
                    if (fieldName === 'phone') {
                        e.target.textContent = field.dataset.originalValue ? `üìû ${field.dataset.originalValue}` : 'üìû Click ƒë·ªÉ nh·∫≠p';
                    } else {
                        e.target.textContent = field.dataset.originalValue || 'Click ƒë·ªÉ nh·∫≠p';
                    }
                    return;
                }

                // If the value is a placeholder 'Click ƒë·ªÉ nh·∫≠p', treat as empty string '.'
                if (newValue === 'Click ƒë·ªÉ nh·∫≠p') {
                    newValue = '.'; // Use '.' as the internal empty value marker, as seen in POST requests
                }

                // Save to backend
                const success = await quickUpdateField(accountId, fieldName, newValue);

                if (success) {
                    field.dataset.originalValue = newValue;
                    // Update display with emoji if phone
                    if (fieldName === 'phone') {
                        e.target.textContent = `üìû ${newValue}`;
                    }
                } else {
                    // Restore original value on failure
                    if (fieldName === 'phone') {
                        e.target.textContent = field.dataset.originalValue ? `üìû ${field.dataset.originalValue}` : 'üìû Click ƒë·ªÉ nh·∫≠p';
                    } else {
                        e.target.textContent = field.dataset.originalValue || 'Click ƒë·ªÉ nh·∫≠p';
                    }
                }
            });

            // Select all text on focus
            field.addEventListener('focus', (e) => {
                // Remove emoji prefix for easier editing
                if (e.target.dataset.field === 'phone') {
                    const phone = e.target.textContent.replace(/^üìû\s*/, '').replace('Click ƒë·ªÉ nh·∫≠p', '').trim();
                    e.target.textContent = phone;
                } else if (e.target.textContent.trim() === 'Click ƒë·ªÉ nh·∫≠p') {
                    e.target.textContent = '';
                }

                // Select all text
                setTimeout(() => {
                    const range = document.createRange();
                    range.selectNodeContents(e.target);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, 0);
            });
        });
    }

    // Toggle account status (click on status to change) - INSTANT UPDATE NO RELOAD
    window.toggleAccountStatus = async function (event, accountId) {
        event.stopPropagation();
        event.preventDefault();

        // Find the account and update locally FIRST (instant UI update)
        const accountIndex = mxhAccounts.findIndex(acc => acc.id === accountId);
        if (accountIndex === -1) return;

        const currentStatus = mxhAccounts[accountIndex].status;

        // Toggle status locally
        const newStatus = currentStatus === 'disabled' ? 'active' : 'disabled';
        mxhAccounts[accountIndex].status = newStatus;

        // Update die_date
        if (newStatus === 'disabled') {
            mxhAccounts[accountIndex].die_date = new Date().toISOString();
        } else {
            mxhAccounts[accountIndex].die_date = null;
        }

        // Re-render immediately (no API call wait)
        scheduleRender();

        // Then update backend in background
        try {
            const response = await fetch(`/mxh/api/accounts/${accountId}/toggle-status`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({})
            });

            if (response.ok) {
                showToast('‚úÖ ƒê√£ thay ƒë·ªïi tr·∫°ng th√°i!', 'success');
            } else {
                // Revert on error
                const error = await response.json();
                showToast(error.error || 'L·ªói khi thay ƒë·ªïi tr·∫°ng th√°i!', 'error');
                await loadMXHData(false); // Reload to get correct data
            }
        } catch (error) {
            showToast('L·ªói k·∫øt n·ªëi!', 'error');
            await loadMXHData(false); // Reload to get correct data
        }
    };

    // ===== MXH BACKGROUND CONTEXT MENU =====
    document.getElementById('mxh-accounts-container').addEventListener('contextmenu', function (event) {
        // Only show if clicked on the container itself, not on cards
        if (event.target.id === 'mxh-accounts-container' || event.target.closest('.row')) {
            event.preventDefault();

            // Hide all other context menus
            document.querySelectorAll('.custom-context-menu').forEach(menu => {
                menu.style.display = 'none';
            });

            // Show background context menu
            const contextMenu = document.getElementById('mxh-background-context-menu');
            contextMenu.style.display = 'block';

            // Smart positioning to avoid overflow
            contextMenu.style.left = event.pageX + 'px';
            contextMenu.style.top = event.pageY + 'px';

            // Calculate menu size and viewport
            let menuRect = contextMenu.getBoundingClientRect();
            const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            const margin = 8;

            let left = event.pageX;
            let top = event.pageY;

            // Horizontal positioning: Smart left/right positioning
            if (menuRect.right > viewportWidth - margin) {
                // Menu will overflow right side of screen
                // Show menu to the left of mouse
                left = event.pageX - menuRect.width;

                // If still overflows left, clamp to left margin
                if (left < margin) {
                    left = margin;
                }
            }

            // Vertical positioning
            if (menuRect.bottom > viewportHeight) {
                // N·∫øu ƒë·ªß ch·ªó ph√≠a tr√™n chu·ªôt th√¨ show l√™n tr√™n
                if (event.pageY - menuRect.height > margin) {
                    top = event.pageY - menuRect.height;
                } else {
                    // N·∫øu kh√¥ng ƒë·ªß ch·ªó tr√™n, th√¨ d√°n s√°t ƒë√°y viewport
                    top = viewportHeight - menuRect.height - margin + window.scrollY;
                    if (top < margin + window.scrollY) top = margin + window.scrollY;
                }
            }

            contextMenu.style.left = left + 'px';
            contextMenu.style.top = top + 'px';
        }
    });

    // Handle background context menu actions
    document.getElementById('mxh-background-context-menu').addEventListener('click', function (event) {
        const action = event.target.closest('.menu-item')?.dataset.action;

        if (action === 'view-mode') {
            // Open view mode modal
            const modal = new bootstrap.Modal(document.getElementById('view-mode-modal'));
            modal.show();
        } else if (action === 'add-account') {
            // Open add account modal
            const modal = new bootstrap.Modal(document.getElementById('mxh-addAccountModal'));
            modal.show();
        }

        // Hide menu
        this.style.display = 'none';
    });

    // Hide all context menus on regular click
    document.addEventListener('click', function (event) {
        // Don't hide if clicking inside a context menu
        if (!event.target.closest('.custom-context-menu')) {
            document.querySelectorAll('.custom-context-menu').forEach(menu => {
                menu.style.display = 'none';
            });

            // Hide all submenus and clear state
            document.querySelectorAll('.submenu').forEach(submenu => {
                submenu.classList.remove('show');
            });
            currentSubmenu = null;
            if (hideTimeout) {
                clearTimeout(hideTimeout);
                hideTimeout = null;
            }
        }
    });

    // ===== SMART SUBMENU POSITIONING =====
    // Function to position submenu smartly
    function positionSubmenu(menuItem) {
        const submenu = menuItem.querySelector('.submenu');
        if (!submenu) return;

        // Temporarily show submenu to measure it
        submenu.style.display = 'block';
        submenu.style.visibility = 'hidden';

        const submenuRect = submenu.getBoundingClientRect();
        const parentMenu = menuItem.closest('.custom-context-menu');
        const parentMenuRect = parentMenu.getBoundingClientRect();
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const margin = 8;

        // Calculate where submenu would appear if positioned normally (right side)
        const normalSubmenuRight = parentMenuRect.right + submenuRect.width;

        // Check if submenu would overflow right side of viewport
        if (normalSubmenuRight > viewportWidth - margin) {
            // Show submenu on the left side
            submenu.classList.add('submenu-left');
            // console.log('Submenu positioned LEFT - would overflow right');
        } else {
            // Show submenu on the right side (default)
            submenu.classList.remove('submenu-left');
            // console.log('Submenu positioned RIGHT - fits in viewport');
        }

        // Hide submenu again (CSS hover will show it)
        submenu.style.display = '';
        submenu.style.visibility = '';
    }

    // Enhanced submenu hover handling with bridge support
    let currentSubmenu = null;
    let hideTimeout = null;

    // Function to create bridge element
    function createSubmenuBridge(submenu, isLeft = false) {
        // Remove existing bridge
        const existingBridge = submenu.querySelector('.submenu-bridge');
        if (existingBridge) {
            existingBridge.remove();
        }

        // Create new bridge
        const bridge = document.createElement('div');
        bridge.className = 'submenu-bridge';
        if (isLeft) {
            bridge.style.left = '-5px';
            bridge.style.right = 'auto';
        }
        submenu.appendChild(bridge);
        return bridge;
    }

    // Function to show submenu
    function showSubmenu(menuItem) {
        // Hide previous submenu
        if (currentSubmenu && currentSubmenu !== menuItem) {
            const prevSubmenu = currentSubmenu.querySelector('.submenu');
            if (prevSubmenu) {
                prevSubmenu.classList.remove('show');
            }
        }

        // Show new submenu
        const submenuEl = menuItem.querySelector('.submenu');
        if (submenuEl) {
            positionSubmenu(menuItem);
            submenuEl.classList.add('show');
            currentSubmenu = menuItem;

            // Create bridge based on position
            const isLeft = submenuEl.classList.contains('submenu-left');
            createSubmenuBridge(submenuEl, isLeft);
        }

        // Clear any pending hide timeout
        if (hideTimeout) {
            clearTimeout(hideTimeout);
            hideTimeout = null;
        }
    }

    // Function to hide submenu with delay
    function hideSubmenu(delay = 100) {
        if (hideTimeout) {
            clearTimeout(hideTimeout);
        }
        hideTimeout = setTimeout(() => {
            if (currentSubmenu) {
                const submenuEl = currentSubmenu.querySelector('.submenu');
                if (submenuEl) {
                    submenuEl.classList.remove('show');
                }
                currentSubmenu = null;
            }
        }, delay);
    }

    // Event listeners
    document.addEventListener('mouseover', function (event) {
        const menuItem = event.target.closest('.menu-item.has-submenu');
        const submenu = event.target.closest('.submenu');
        const bridge = event.target.closest('.submenu-bridge');

        if (menuItem) {
            showSubmenu(menuItem);
        } else if (submenu || bridge) {
            // Keep submenu open when hovering over submenu or bridge
            if (currentSubmenu) {
                const submenuEl = currentSubmenu.querySelector('.submenu');
                if (submenuEl) {
                    submenuEl.classList.add('show');
                }
                if (hideTimeout) {
                    clearTimeout(hideTimeout);
                    hideTimeout = null;
                }
            }
        }
    });

    document.addEventListener('mouseout', function (event) {
        const menuItem = event.target.closest('.menu-item.has-submenu');
        const submenu = event.target.closest('.submenu');
        const bridge = event.target.closest('.submenu-bridge');

        if (!menuItem && !submenu && !bridge) {
            // Hide submenu when leaving all related elements
            hideSubmenu();
        }
    });

    // Also position submenus when context menu is shown
    function positionAllSubmenus(menuId) {
        setTimeout(() => {
            const menu = document.getElementById(menuId);
            if (menu) {
                const submenuItems = menu.querySelectorAll('.menu-item.has-submenu');
                submenuItems.forEach(positionSubmenu);
            }
        }, 10);
    }

    // ===== AUTO-FILL DATE WHEN OPENING ADD ACCOUNT MODAL =====
    const mxhAddAccountModal = document.getElementById('mxh-addAccountModal');
    if (mxhAddAccountModal) {
        mxhAddAccountModal.addEventListener('shown.bs.modal', function () {
            // Get current date
            const today = new Date();
            const day = today.getDate();
            const month = today.getMonth() + 1; // JavaScript months are 0-indexed
            const year = today.getFullYear();

            // Auto-fill date inputs
            document.getElementById('mxh-day').value = day;
            document.getElementById('mxh-month').value = month;
            document.getElementById('mxh-year').value = year;

            // Clear other fields
            document.getElementById('mxh-username').value = '';
            document.getElementById('mxh-platform').value = '';
            document.getElementById('mxh-password').value = '';
            document.getElementById('mxh-phone').value = '';
            document.getElementById('mxh-url').value = '';
        });
    }

    // ===== AUTO-FILL DATE WHEN OPENING WECHAT MODAL (for adding new) =====
    const wechatAccountModal = document.getElementById('wechat-account-modal');
    if (wechatAccountModal) {
        wechatAccountModal.addEventListener('shown.bs.modal', function () {
            // Only auto-fill if it's a new account (all fields empty)
            const cardName = document.getElementById('wechat-card-name').value;
            const username = document.getElementById('wechat-username').value;

            // If both are empty, it's likely a new account
            if (!cardName && !username) {
                const today = new Date();
                const day = today.getDate();
                const month = today.getMonth() + 1;
                const year = today.getFullYear();

                // Auto-fill date input only if it's empty
                if (!document.getElementById('wechat-date').value) {
                    document.getElementById('wechat-date').value = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;
                }
            }
        });
    }

    // ===== AUTO-FORMAT DATE INPUT =====
    document.addEventListener('DOMContentLoaded', function () {
        const dateInput = document.getElementById('wechat-date');

        if (dateInput) {
            dateInput.addEventListener('input', function (e) {
                let value = e.target.value.replace(/\D/g, ''); // Remove non-digits

                if (value.length >= 2) {
                    value = value.slice(0, 2) + '/' + value.slice(2);
                }
                if (value.length >= 5) {
                    value = value.slice(0, 5) + '/' + value.slice(5, 9);
                }

                e.target.value = value;
            });

            // Handle backspace
            dateInput.addEventListener('keydown', function (e) {
                if (e.key === 'Backspace') {
                    const cursorPos = this.selectionStart;
                    const value = this.value;

                    // If cursor is right after a slash, move it before the slash
                    if (cursorPos > 0 && value[cursorPos - 1] === '/') {
                        e.preventDefault();
                        this.setSelectionRange(cursorPos - 1, cursorPos - 1);
                    }
                }
            });

            // Handle paste
            dateInput.addEventListener('paste', function (e) {
                e.preventDefault();
                let pastedData = e.clipboardData.getData('text').replace(/\D/g, '');

                if (pastedData.length >= 8) {
                    const day = pastedData.slice(0, 2);
                    const month = pastedData.slice(2, 4);
                    const year = pastedData.slice(4, 8);
                    this.value = day + '/' + month + '/' + year;
                } else if (pastedData.length >= 4) {
                    const day = pastedData.slice(0, 2);
                    const month = pastedData.slice(2, 4);
                    this.value = day + '/' + month + '/';
                } else {
                    this.value = pastedData;
                }
            });
        }
    });

</script>
{% endblock %}